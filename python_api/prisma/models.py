# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class allergies(bases.Baseallergies):
    """Represents a allergies record"""

    allergyid: _int
    name: _str
    description: Optional[_str] = None
    patients_allergies: Optional[List['models.patients_allergies']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.allergiesKeys']] = None,
        exclude: Optional[Iterable['types.allergiesKeys']] = None,
        required: Optional[Iterable['types.allergiesKeys']] = None,
        optional: Optional[Iterable['types.allergiesKeys']] = None,
        relations: Optional[Mapping['types.allergiesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.allergiesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _allergies_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _allergies_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _allergies_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _allergies_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _allergies_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _allergies_relational_fields:
                        raise errors.UnknownRelationalFieldError('allergies', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid allergies / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'allergies',
            }
        )
        _created_partial_types.add(name)


class booster_shots(bases.Basebooster_shots):
    """Represents a booster_shots record"""

    boostershotid: _int
    type: _str
    initialdate: datetime.datetime
    executiondate: Optional[datetime.datetime] = None
    status: 'enums.statuts'
    patientid: _int
    patients: Optional['models.patients'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.booster_shotsKeys']] = None,
        exclude: Optional[Iterable['types.booster_shotsKeys']] = None,
        required: Optional[Iterable['types.booster_shotsKeys']] = None,
        optional: Optional[Iterable['types.booster_shotsKeys']] = None,
        relations: Optional[Mapping['types.booster_shotsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.booster_shotsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _booster_shots_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _booster_shots_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _booster_shots_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _booster_shots_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _booster_shots_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _booster_shots_relational_fields:
                        raise errors.UnknownRelationalFieldError('booster_shots', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid booster_shots / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'booster_shots',
            }
        )
        _created_partial_types.add(name)


class clients(bases.Baseclients):
    """Represents a clients record"""

    clientid: _int
    lastname: _str
    firstname: _str
    gender: 'enums.genders'
    phonenumber: _str
    email: Optional[_str] = None
    address: Optional[_str] = None
    zipcode: Optional[_str] = None
    city: Optional[_str] = None
    earnings: Optional[List['models.earnings']] = None
    events: Optional[List['models.events']] = None
    invoices: Optional[List['models.invoices']] = None
    patients: Optional[List['models.patients']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.clientsKeys']] = None,
        exclude: Optional[Iterable['types.clientsKeys']] = None,
        required: Optional[Iterable['types.clientsKeys']] = None,
        optional: Optional[Iterable['types.clientsKeys']] = None,
        relations: Optional[Mapping['types.clientsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.clientsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _clients_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _clients_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _clients_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _clients_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _clients_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _clients_relational_fields:
                        raise errors.UnknownRelationalFieldError('clients', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid clients / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'clients',
            }
        )
        _created_partial_types.add(name)


class earnings(bases.Baseearnings):
    """Represents a earnings record"""

    earningid: _int
    amount: decimal.Decimal
    description: Optional[_str] = None
    created_at: datetime.datetime
    paymentstatus: Optional['enums.payment'] = None
    clientid: _int
    clients: Optional['models.clients'] = None
    invoices: Optional[List['models.invoices']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.earningsKeys']] = None,
        exclude: Optional[Iterable['types.earningsKeys']] = None,
        required: Optional[Iterable['types.earningsKeys']] = None,
        optional: Optional[Iterable['types.earningsKeys']] = None,
        relations: Optional[Mapping['types.earningsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.earningsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _earnings_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _earnings_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _earnings_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _earnings_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _earnings_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _earnings_relational_fields:
                        raise errors.UnknownRelationalFieldError('earnings', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid earnings / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'earnings',
            }
        )
        _created_partial_types.add(name)


class events(bases.Baseevents):
    """Represents a events record"""

    eventid: _int
    title: _str
    description: Optional[_str] = None
    type: 'enums.event_type'
    eventdate: datetime.datetime
    starthour: datetime.datetime
    endhour: datetime.datetime
    status: 'enums.statuts'
    userid: _int
    patientid: Optional[_int] = None
    clientid: Optional[_int] = None
    clients: Optional['models.clients'] = None
    patients: Optional['models.patients'] = None
    users: Optional['models.users'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.eventsKeys']] = None,
        exclude: Optional[Iterable['types.eventsKeys']] = None,
        required: Optional[Iterable['types.eventsKeys']] = None,
        optional: Optional[Iterable['types.eventsKeys']] = None,
        relations: Optional[Mapping['types.eventsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.eventsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _events_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _events_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _events_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _events_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _events_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _events_relational_fields:
                        raise errors.UnknownRelationalFieldError('events', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid events / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'events',
            }
        )
        _created_partial_types.add(name)


class expenses(bases.Baseexpenses):
    """Represents a expenses record"""

    expenseid: _int
    amount: decimal.Decimal
    description: Optional[_str] = None
    created_at: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.expensesKeys']] = None,
        exclude: Optional[Iterable['types.expensesKeys']] = None,
        required: Optional[Iterable['types.expensesKeys']] = None,
        optional: Optional[Iterable['types.expensesKeys']] = None,
        relations: Optional[Mapping['types.expensesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.expensesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _expenses_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _expenses_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _expenses_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _expenses_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "expenses" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid expenses / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'expenses',
            }
        )
        _created_partial_types.add(name)


class invoices(bases.Baseinvoices):
    """Represents a invoices record"""

    invoiceid: _int
    amount: decimal.Decimal
    invoicelink: _str
    created_at: datetime.datetime
    clientid: _int
    earningid: _int
    clients: Optional['models.clients'] = None
    earnings: Optional['models.earnings'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.invoicesKeys']] = None,
        exclude: Optional[Iterable['types.invoicesKeys']] = None,
        required: Optional[Iterable['types.invoicesKeys']] = None,
        optional: Optional[Iterable['types.invoicesKeys']] = None,
        relations: Optional[Mapping['types.invoicesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.invoicesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _invoices_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _invoices_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _invoices_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _invoices_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _invoices_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _invoices_relational_fields:
                        raise errors.UnknownRelationalFieldError('invoices', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid invoices / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'invoices',
            }
        )
        _created_partial_types.add(name)


class items_bought(bases.Baseitems_bought):
    """Represents a items_bought record"""

    expenseid: _int
    productid: _int
    quantity: _int

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.items_boughtKeys']] = None,
        exclude: Optional[Iterable['types.items_boughtKeys']] = None,
        required: Optional[Iterable['types.items_boughtKeys']] = None,
        optional: Optional[Iterable['types.items_boughtKeys']] = None,
        relations: Optional[Mapping['types.items_boughtRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.items_boughtKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _items_bought_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _items_bought_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _items_bought_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _items_bought_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "items_bought" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid items_bought / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'items_bought',
            }
        )
        _created_partial_types.add(name)


class items_sold(bases.Baseitems_sold):
    """Represents a items_sold record"""

    earningid: _int
    productid: _int
    quantity: _int

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.items_soldKeys']] = None,
        exclude: Optional[Iterable['types.items_soldKeys']] = None,
        required: Optional[Iterable['types.items_soldKeys']] = None,
        optional: Optional[Iterable['types.items_soldKeys']] = None,
        relations: Optional[Mapping['types.items_soldRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.items_soldKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _items_sold_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _items_sold_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _items_sold_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _items_sold_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "items_sold" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid items_sold / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'items_sold',
            }
        )
        _created_partial_types.add(name)


class patients(bases.Basepatients):
    """Represents a patients record"""

    patientid: _int
    name: _str
    gender: 'enums.genders'
    type: _str
    species: Optional[_str] = None
    birthdate: Optional[datetime.datetime] = None
    numberid: Optional[_int] = None
    color: Optional[_str] = None
    clientid: _int
    booster_shots: Optional[List['models.booster_shots']] = None
    events: Optional[List['models.events']] = None
    clients: Optional['models.clients'] = None
    patients_allergies: Optional[List['models.patients_allergies']] = None
    prescriptions: Optional[List['models.prescriptions']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.patientsKeys']] = None,
        exclude: Optional[Iterable['types.patientsKeys']] = None,
        required: Optional[Iterable['types.patientsKeys']] = None,
        optional: Optional[Iterable['types.patientsKeys']] = None,
        relations: Optional[Mapping['types.patientsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.patientsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _patients_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _patients_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _patients_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _patients_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _patients_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _patients_relational_fields:
                        raise errors.UnknownRelationalFieldError('patients', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid patients / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'patients',
            }
        )
        _created_partial_types.add(name)


class patients_allergies(bases.Basepatients_allergies):
    """Represents a patients_allergies record"""

    patientid: _int
    allergyid: _int
    status: 'enums.statuses'
    allergies: Optional['models.allergies'] = None
    patients: Optional['models.patients'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.patients_allergiesKeys']] = None,
        exclude: Optional[Iterable['types.patients_allergiesKeys']] = None,
        required: Optional[Iterable['types.patients_allergiesKeys']] = None,
        optional: Optional[Iterable['types.patients_allergiesKeys']] = None,
        relations: Optional[Mapping['types.patients_allergiesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.patients_allergiesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _patients_allergies_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _patients_allergies_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _patients_allergies_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _patients_allergies_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _patients_allergies_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _patients_allergies_relational_fields:
                        raise errors.UnknownRelationalFieldError('patients_allergies', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid patients_allergies / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'patients_allergies',
            }
        )
        _created_partial_types.add(name)


class prescriptions(bases.Baseprescriptions):
    """Represents a prescriptions record"""

    prescriptionid: _int
    motive: Optional[_str] = None
    prescriptionlink: _str
    created_at: datetime.datetime
    patientid: _int
    patients: Optional['models.patients'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.prescriptionsKeys']] = None,
        exclude: Optional[Iterable['types.prescriptionsKeys']] = None,
        required: Optional[Iterable['types.prescriptionsKeys']] = None,
        optional: Optional[Iterable['types.prescriptionsKeys']] = None,
        relations: Optional[Mapping['types.prescriptionsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.prescriptionsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _prescriptions_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _prescriptions_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _prescriptions_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _prescriptions_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _prescriptions_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _prescriptions_relational_fields:
                        raise errors.UnknownRelationalFieldError('prescriptions', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid prescriptions / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'prescriptions',
            }
        )
        _created_partial_types.add(name)


class product_types(bases.Baseproduct_types):
    """Represents a product_types record"""

    producttypeid: _int
    name: _str
    products: Optional[List['models.products']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.product_typesKeys']] = None,
        exclude: Optional[Iterable['types.product_typesKeys']] = None,
        required: Optional[Iterable['types.product_typesKeys']] = None,
        optional: Optional[Iterable['types.product_typesKeys']] = None,
        relations: Optional[Mapping['types.product_typesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.product_typesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _product_types_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _product_types_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _product_types_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _product_types_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _product_types_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _product_types_relational_fields:
                        raise errors.UnknownRelationalFieldError('product_types', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid product_types / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'product_types',
            }
        )
        _created_partial_types.add(name)


class products(bases.Baseproducts):
    """Represents a products record"""

    productid: _int
    name: _str
    description: Optional[_str] = None
    sellingprice: decimal.Decimal
    cost: decimal.Decimal
    tva: decimal.Decimal
    quantity: _int
    producttypeid: _int
    product_types: Optional['models.product_types'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.productsKeys']] = None,
        exclude: Optional[Iterable['types.productsKeys']] = None,
        required: Optional[Iterable['types.productsKeys']] = None,
        optional: Optional[Iterable['types.productsKeys']] = None,
        relations: Optional[Mapping['types.productsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.productsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _products_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _products_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _products_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _products_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _products_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _products_relational_fields:
                        raise errors.UnknownRelationalFieldError('products', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid products / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'products',
            }
        )
        _created_partial_types.add(name)


class users(bases.Baseusers):
    """Represents a users record"""

    userid: _int
    username: _str
    password: _str
    role: 'enums.roles'
    events: Optional[List['models.events']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.usersKeys']] = None,
        exclude: Optional[Iterable['types.usersKeys']] = None,
        required: Optional[Iterable['types.usersKeys']] = None,
        optional: Optional[Iterable['types.usersKeys']] = None,
        relations: Optional[Mapping['types.usersRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.usersKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _users_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _users_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _users_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _users_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _users_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _users_relational_fields:
                        raise errors.UnknownRelationalFieldError('users', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid users / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'users',
            }
        )
        _created_partial_types.add(name)



_allergies_relational_fields: Set[str] = {
        'patients_allergies',
    }
_allergies_fields: Dict['types.allergiesKeys', PartialModelField] = OrderedDict(
    [
        ('allergyid', {
            'name': 'allergyid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('patients_allergies', {
            'name': 'patients_allergies',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.patients_allergies\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_booster_shots_relational_fields: Set[str] = {
        'patients',
    }
_booster_shots_fields: Dict['types.booster_shotsKeys', PartialModelField] = OrderedDict(
    [
        ('boostershotid', {
            'name': 'boostershotid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('initialdate', {
            'name': 'initialdate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('executiondate', {
            'name': 'executiondate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.statuts',
            'is_relational': False,
            'documentation': None,
        }),
        ('patientid', {
            'name': 'patientid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('patients', {
            'name': 'patients',
            'is_list': False,
            'optional': True,
            'type': 'models.patients',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_clients_relational_fields: Set[str] = {
        'earnings',
        'events',
        'invoices',
        'patients',
    }
_clients_fields: Dict['types.clientsKeys', PartialModelField] = OrderedDict(
    [
        ('clientid', {
            'name': 'clientid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastname', {
            'name': 'lastname',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('firstname', {
            'name': 'firstname',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('gender', {
            'name': 'gender',
            'is_list': False,
            'optional': False,
            'type': 'enums.genders',
            'is_relational': False,
            'documentation': None,
        }),
        ('phonenumber', {
            'name': 'phonenumber',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('address', {
            'name': 'address',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('zipcode', {
            'name': 'zipcode',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('city', {
            'name': 'city',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('earnings', {
            'name': 'earnings',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.earnings\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('events', {
            'name': 'events',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.events\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('invoices', {
            'name': 'invoices',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.invoices\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('patients', {
            'name': 'patients',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.patients\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_earnings_relational_fields: Set[str] = {
        'clients',
        'invoices',
    }
_earnings_fields: Dict['types.earningsKeys', PartialModelField] = OrderedDict(
    [
        ('earningid', {
            'name': 'earningid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('amount', {
            'name': 'amount',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('paymentstatus', {
            'name': 'paymentstatus',
            'is_list': False,
            'optional': True,
            'type': 'enums.payment',
            'is_relational': False,
            'documentation': None,
        }),
        ('clientid', {
            'name': 'clientid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('clients', {
            'name': 'clients',
            'is_list': False,
            'optional': True,
            'type': 'models.clients',
            'is_relational': True,
            'documentation': None,
        }),
        ('invoices', {
            'name': 'invoices',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.invoices\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_events_relational_fields: Set[str] = {
        'clients',
        'patients',
        'users',
    }
_events_fields: Dict['types.eventsKeys', PartialModelField] = OrderedDict(
    [
        ('eventid', {
            'name': 'eventid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': 'enums.event_type',
            'is_relational': False,
            'documentation': None,
        }),
        ('eventdate', {
            'name': 'eventdate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('starthour', {
            'name': 'starthour',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('endhour', {
            'name': 'endhour',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.statuts',
            'is_relational': False,
            'documentation': None,
        }),
        ('userid', {
            'name': 'userid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('patientid', {
            'name': 'patientid',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('clientid', {
            'name': 'clientid',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('clients', {
            'name': 'clients',
            'is_list': False,
            'optional': True,
            'type': 'models.clients',
            'is_relational': True,
            'documentation': None,
        }),
        ('patients', {
            'name': 'patients',
            'is_list': False,
            'optional': True,
            'type': 'models.patients',
            'is_relational': True,
            'documentation': None,
        }),
        ('users', {
            'name': 'users',
            'is_list': False,
            'optional': True,
            'type': 'models.users',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_expenses_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_expenses_fields: Dict['types.expensesKeys', PartialModelField] = OrderedDict(
    [
        ('expenseid', {
            'name': 'expenseid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('amount', {
            'name': 'amount',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_invoices_relational_fields: Set[str] = {
        'clients',
        'earnings',
    }
_invoices_fields: Dict['types.invoicesKeys', PartialModelField] = OrderedDict(
    [
        ('invoiceid', {
            'name': 'invoiceid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('amount', {
            'name': 'amount',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('invoicelink', {
            'name': 'invoicelink',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('clientid', {
            'name': 'clientid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('earningid', {
            'name': 'earningid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('clients', {
            'name': 'clients',
            'is_list': False,
            'optional': True,
            'type': 'models.clients',
            'is_relational': True,
            'documentation': None,
        }),
        ('earnings', {
            'name': 'earnings',
            'is_list': False,
            'optional': True,
            'type': 'models.earnings',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_items_bought_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_items_bought_fields: Dict['types.items_boughtKeys', PartialModelField] = OrderedDict(
    [
        ('expenseid', {
            'name': 'expenseid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('productid', {
            'name': 'productid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('quantity', {
            'name': 'quantity',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_items_sold_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_items_sold_fields: Dict['types.items_soldKeys', PartialModelField] = OrderedDict(
    [
        ('earningid', {
            'name': 'earningid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('productid', {
            'name': 'productid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('quantity', {
            'name': 'quantity',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_patients_relational_fields: Set[str] = {
        'booster_shots',
        'events',
        'clients',
        'patients_allergies',
        'prescriptions',
    }
_patients_fields: Dict['types.patientsKeys', PartialModelField] = OrderedDict(
    [
        ('patientid', {
            'name': 'patientid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('gender', {
            'name': 'gender',
            'is_list': False,
            'optional': False,
            'type': 'enums.genders',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('species', {
            'name': 'species',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('birthdate', {
            'name': 'birthdate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('numberid', {
            'name': 'numberid',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('color', {
            'name': 'color',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('clientid', {
            'name': 'clientid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('booster_shots', {
            'name': 'booster_shots',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.booster_shots\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('events', {
            'name': 'events',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.events\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('clients', {
            'name': 'clients',
            'is_list': False,
            'optional': True,
            'type': 'models.clients',
            'is_relational': True,
            'documentation': None,
        }),
        ('patients_allergies', {
            'name': 'patients_allergies',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.patients_allergies\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('prescriptions', {
            'name': 'prescriptions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.prescriptions\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_patients_allergies_relational_fields: Set[str] = {
        'allergies',
        'patients',
    }
_patients_allergies_fields: Dict['types.patients_allergiesKeys', PartialModelField] = OrderedDict(
    [
        ('patientid', {
            'name': 'patientid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('allergyid', {
            'name': 'allergyid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.statuses',
            'is_relational': False,
            'documentation': None,
        }),
        ('allergies', {
            'name': 'allergies',
            'is_list': False,
            'optional': True,
            'type': 'models.allergies',
            'is_relational': True,
            'documentation': None,
        }),
        ('patients', {
            'name': 'patients',
            'is_list': False,
            'optional': True,
            'type': 'models.patients',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_prescriptions_relational_fields: Set[str] = {
        'patients',
    }
_prescriptions_fields: Dict['types.prescriptionsKeys', PartialModelField] = OrderedDict(
    [
        ('prescriptionid', {
            'name': 'prescriptionid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('motive', {
            'name': 'motive',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('prescriptionlink', {
            'name': 'prescriptionlink',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('patientid', {
            'name': 'patientid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('patients', {
            'name': 'patients',
            'is_list': False,
            'optional': True,
            'type': 'models.patients',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_product_types_relational_fields: Set[str] = {
        'products',
    }
_product_types_fields: Dict['types.product_typesKeys', PartialModelField] = OrderedDict(
    [
        ('producttypeid', {
            'name': 'producttypeid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('products', {
            'name': 'products',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.products\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_products_relational_fields: Set[str] = {
        'product_types',
    }
_products_fields: Dict['types.productsKeys', PartialModelField] = OrderedDict(
    [
        ('productid', {
            'name': 'productid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('sellingprice', {
            'name': 'sellingprice',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('cost', {
            'name': 'cost',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('tva', {
            'name': 'tva',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('quantity', {
            'name': 'quantity',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('producttypeid', {
            'name': 'producttypeid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('product_types', {
            'name': 'product_types',
            'is_list': False,
            'optional': True,
            'type': 'models.product_types',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_users_relational_fields: Set[str] = {
        'events',
    }
_users_fields: Dict['types.usersKeys', PartialModelField] = OrderedDict(
    [
        ('userid', {
            'name': 'userid',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('username', {
            'name': 'username',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('password', {
            'name': 'password',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': 'enums.roles',
            'is_relational': False,
            'documentation': None,
        }),
        ('events', {
            'name': 'events',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.events\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(allergies)
model_rebuild(booster_shots)
model_rebuild(clients)
model_rebuild(earnings)
model_rebuild(events)
model_rebuild(expenses)
model_rebuild(invoices)
model_rebuild(items_bought)
model_rebuild(items_sold)
model_rebuild(patients)
model_rebuild(patients_allergies)
model_rebuild(prescriptions)
model_rebuild(product_types)
model_rebuild(products)
model_rebuild(users)
