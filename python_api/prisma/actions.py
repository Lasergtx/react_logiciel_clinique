# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class allergiesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.allergies]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await allergies.prisma().query_raw(
            'SELECT * FROM allergies WHERE allergyid = $1',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.allergies
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await allergies.prisma().query_first(
            'SELECT * FROM allergies WHERE name = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.allergiesCreateInput,
        include: Optional[types.allergiesInclude] = None
    ) -> _PrismaModelT:
        """Create a new allergies record.

        Parameters
        ----------
        data
            allergies record data
        include
            Specifies which relations should be loaded on the returned allergies model

        Returns
        -------
        prisma.models.allergies
            The created allergies record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a allergies record from just the required fields
        allergies = await allergies.prisma().create(
            data={
                # data to create a allergies record
                'name': 'ggciceaie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.allergiesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple allergies records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of allergies record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await allergies.prisma().create_many(
            data=[
                {
                    # data to create a allergies record
                    'name': 'bbehjachib',
                },
                {
                    # data to create a allergies record
                    'name': 'cadfabfehe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.allergiesWhereUniqueInput,
        include: Optional[types.allergiesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single allergies record.

        Parameters
        ----------
        where
            allergies filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned allergies model

        Returns
        -------
        prisma.models.allergies
            The deleted allergies record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        allergies = await allergies.prisma().delete(
            where={
                'allergyid': 368800899,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.allergiesWhereUniqueInput,
        include: Optional[types.allergiesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique allergies record.

        Parameters
        ----------
        where
            allergies filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned allergies model

        Returns
        -------
        prisma.models.allergies
            The found allergies record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        allergies = await allergies.prisma().find_unique(
            where={
                'allergyid': 1508029952,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.allergiesWhereUniqueInput,
        include: Optional[types.allergiesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique allergies record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            allergies filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned allergies model

        Returns
        -------
        prisma.models.allergies
            The found allergies record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        allergies = await allergies.prisma().find_unique_or_raise(
            where={
                'allergyid': 486256185,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.allergiesWhereInput] = None,
        cursor: Optional[types.allergiesWhereUniqueInput] = None,
        include: Optional[types.allergiesInclude] = None,
        order: Optional[Union[types.allergiesOrderByInput, List[types.allergiesOrderByInput]]] = None,
        distinct: Optional[List[types.allergiesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple allergies records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of allergies records returned
        skip
            Ignore the first N results
        where
            allergies filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned allergies model
        order
            Order the returned allergies records by any field
        distinct
            Filter allergies records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.allergies]
            The list of all allergies records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 allergies records
        allergies = await allergies.prisma().find_many(take=10)

        # find the first 5 allergies records ordered by the description field
        allergies = await allergies.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.allergiesWhereInput] = None,
        cursor: Optional[types.allergiesWhereUniqueInput] = None,
        include: Optional[types.allergiesInclude] = None,
        order: Optional[Union[types.allergiesOrderByInput, List[types.allergiesOrderByInput]]] = None,
        distinct: Optional[List[types.allergiesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single allergies record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            allergies filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned allergies model
        order
            Order the returned allergies records by any field
        distinct
            Filter allergies records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.allergies
            The first allergies record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second allergies record ordered by the allergyid field
        allergies = await allergies.prisma().find_first(
            skip=1,
            order={
                'allergyid': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.allergiesWhereInput] = None,
        cursor: Optional[types.allergiesWhereUniqueInput] = None,
        include: Optional[types.allergiesInclude] = None,
        order: Optional[Union[types.allergiesOrderByInput, List[types.allergiesOrderByInput]]] = None,
        distinct: Optional[List[types.allergiesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single allergies record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            allergies filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned allergies model
        order
            Order the returned allergies records by any field
        distinct
            Filter allergies records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.allergies
            The first allergies record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second allergies record ordered by the name field
        allergies = await allergies.prisma().find_first_or_raise(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.allergiesUpdateInput,
        where: types.allergiesWhereUniqueInput,
        include: Optional[types.allergiesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single allergies record.

        Parameters
        ----------
        data
            allergies record data specifying what to update
        where
            allergies filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned allergies model

        Returns
        -------
        prisma.models.allergies
            The updated allergies record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        allergies = await allergies.prisma().update(
            where={
                'allergyid': 1062517886,
            },
            data={
                # data to update the allergies record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.allergiesWhereUniqueInput,
        data: types.allergiesUpsertInput,
        include: Optional[types.allergiesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            allergies filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned allergies model

        Returns
        -------
        prisma.models.allergies
            The created or updated allergies record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        allergies = await allergies.prisma().upsert(
            where={
                'allergyid': 267834847,
            },
            data={
                'create': {
                    'allergyid': 267834847,
                    'name': 'cadfabfehe',
                },
                'update': {
                    'name': 'cadfabfehe',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.allergiesUpdateManyMutationInput,
        where: types.allergiesWhereInput,
    ) -> int:
        """Update multiple allergies records

        Parameters
        ----------
        data
            allergies data to update the selected allergies records to
        where
            Filter to select the allergies records to update

        Returns
        -------
        int
            The total number of allergies records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all allergies records
        total = await allergies.prisma().update_many(
            data={
                'description': 'biabhbdai'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.allergiesWhereInput] = None,
        cursor: Optional[types.allergiesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of allergies records present in the database

        Parameters
        ----------
        select
            Select the allergies fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            allergies filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.allergiesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await allergies.prisma().count()

        # results: prisma.types.allergiesCountAggregateOutput
        results = await allergies.prisma().count(
            select={
                '_all': True,
                'allergyid': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.allergiesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.allergiesWhereInput] = None,
        cursor: Optional[types.allergiesWhereUniqueInput] = None,
    ) -> types.allergiesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.allergiesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.allergiesWhereInput] = None,
        cursor: Optional[types.allergiesWhereUniqueInput] = None,
    ) -> Union[int, types.allergiesCountAggregateOutput]:
        """Count the number of allergies records present in the database

        Parameters
        ----------
        select
            Select the allergies fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            allergies filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.allergiesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await allergies.prisma().count()

        # results: prisma.types.allergiesCountAggregateOutput
        results = await allergies.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.allergiesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.allergiesWhereInput] = None
    ) -> int:
        """Delete multiple allergies records.

        Parameters
        ----------
        where
            Optional allergies filter to find the records to be deleted

        Returns
        -------
        int
            The total number of allergies records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all allergies records
        total = await allergies.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.allergiesScalarFieldKeys'],
        *,
        where: Optional['types.allergiesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.allergiesAvgAggregateInput'] = None,
        sum: Optional['types.allergiesSumAggregateInput'] = None,
        min: Optional['types.allergiesMinAggregateInput'] = None,
        max: Optional['types.allergiesMaxAggregateInput'] = None,
        having: Optional['types.allergiesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.allergiesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.allergiesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.allergiesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.allergiesGroupByOutput']:
        """Group allergies records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar allergies fields to group records by
        where
            allergies filter to select records
        take
            Limit the maximum number of allergies records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.allergiesGroupByOutput]
            A list of dictionaries representing the allergies record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group allergies records by description values
        # and count how many records are in each group
        results = await allergies.prisma().group_by(
            ['description'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class booster_shotsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.booster_shots]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await booster_shots.prisma().query_raw(
            'SELECT * FROM booster_shots WHERE boostershotid = $1',
            836760821,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.booster_shots
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await booster_shots.prisma().query_first(
            'SELECT * FROM booster_shots WHERE type = $1',
            'fjfddhigg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.booster_shotsCreateInput,
        include: Optional[types.booster_shotsInclude] = None
    ) -> _PrismaModelT:
        """Create a new booster_shots record.

        Parameters
        ----------
        data
            booster_shots record data
        include
            Specifies which relations should be loaded on the returned booster_shots model

        Returns
        -------
        prisma.models.booster_shots
            The created booster_shots record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a booster_shots record from just the required fields
        booster_shots = await booster_shots.prisma().create(
            data={
                # data to create a booster_shots record
                'type': 'hjaecfifb',
                'initialdate': datetime.datetime.utcnow(),
                'status': enums.statuts.AVENIR,
                'patientid': 2111915288,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.booster_shotsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple booster_shots records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of booster_shots record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await booster_shots.prisma().create_many(
            data=[
                {
                    # data to create a booster_shots record
                    'type': 'bbejhfidcb',
                    'initialdate': datetime.datetime.utcnow(),
                    'status': enums.statuts.AVENIR,
                    'patientid': 1644289366,
                },
                {
                    # data to create a booster_shots record
                    'type': 'bdiicjafbj',
                    'initialdate': datetime.datetime.utcnow(),
                    'status': enums.statuts.AVENIR,
                    'patientid': 1647418052,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.booster_shotsWhereUniqueInput,
        include: Optional[types.booster_shotsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single booster_shots record.

        Parameters
        ----------
        where
            booster_shots filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned booster_shots model

        Returns
        -------
        prisma.models.booster_shots
            The deleted booster_shots record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        booster_shots = await booster_shots.prisma().delete(
            where={
                'boostershotid': 1675546029,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.booster_shotsWhereUniqueInput,
        include: Optional[types.booster_shotsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique booster_shots record.

        Parameters
        ----------
        where
            booster_shots filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned booster_shots model

        Returns
        -------
        prisma.models.booster_shots
            The found booster_shots record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        booster_shots = await booster_shots.prisma().find_unique(
            where={
                'boostershotid': 1767274722,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.booster_shotsWhereUniqueInput,
        include: Optional[types.booster_shotsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique booster_shots record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            booster_shots filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned booster_shots model

        Returns
        -------
        prisma.models.booster_shots
            The found booster_shots record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        booster_shots = await booster_shots.prisma().find_unique_or_raise(
            where={
                'boostershotid': 326272115,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.booster_shotsWhereInput] = None,
        cursor: Optional[types.booster_shotsWhereUniqueInput] = None,
        include: Optional[types.booster_shotsInclude] = None,
        order: Optional[Union[types.booster_shotsOrderByInput, List[types.booster_shotsOrderByInput]]] = None,
        distinct: Optional[List[types.booster_shotsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple booster_shots records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of booster_shots records returned
        skip
            Ignore the first N results
        where
            booster_shots filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned booster_shots model
        order
            Order the returned booster_shots records by any field
        distinct
            Filter booster_shots records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.booster_shots]
            The list of all booster_shots records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 booster_shots records
        booster_shots = await booster_shots.prisma().find_many(take=10)

        # find the first 5 booster_shots records ordered by the initialdate field
        booster_shots = await booster_shots.prisma().find_many(
            take=5,
            order={
                'initialdate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.booster_shotsWhereInput] = None,
        cursor: Optional[types.booster_shotsWhereUniqueInput] = None,
        include: Optional[types.booster_shotsInclude] = None,
        order: Optional[Union[types.booster_shotsOrderByInput, List[types.booster_shotsOrderByInput]]] = None,
        distinct: Optional[List[types.booster_shotsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single booster_shots record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            booster_shots filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned booster_shots model
        order
            Order the returned booster_shots records by any field
        distinct
            Filter booster_shots records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.booster_shots
            The first booster_shots record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second booster_shots record ordered by the executiondate field
        booster_shots = await booster_shots.prisma().find_first(
            skip=1,
            order={
                'executiondate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.booster_shotsWhereInput] = None,
        cursor: Optional[types.booster_shotsWhereUniqueInput] = None,
        include: Optional[types.booster_shotsInclude] = None,
        order: Optional[Union[types.booster_shotsOrderByInput, List[types.booster_shotsOrderByInput]]] = None,
        distinct: Optional[List[types.booster_shotsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single booster_shots record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            booster_shots filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned booster_shots model
        order
            Order the returned booster_shots records by any field
        distinct
            Filter booster_shots records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.booster_shots
            The first booster_shots record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second booster_shots record ordered by the status field
        booster_shots = await booster_shots.prisma().find_first_or_raise(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.booster_shotsUpdateInput,
        where: types.booster_shotsWhereUniqueInput,
        include: Optional[types.booster_shotsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single booster_shots record.

        Parameters
        ----------
        data
            booster_shots record data specifying what to update
        where
            booster_shots filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned booster_shots model

        Returns
        -------
        prisma.models.booster_shots
            The updated booster_shots record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        booster_shots = await booster_shots.prisma().update(
            where={
                'boostershotid': 1343201072,
            },
            data={
                # data to update the booster_shots record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.booster_shotsWhereUniqueInput,
        data: types.booster_shotsUpsertInput,
        include: Optional[types.booster_shotsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            booster_shots filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned booster_shots model

        Returns
        -------
        prisma.models.booster_shots
            The created or updated booster_shots record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        booster_shots = await booster_shots.prisma().upsert(
            where={
                'boostershotid': 675780521,
            },
            data={
                'create': {
                    'boostershotid': 675780521,
                    'type': 'bdiicjafbj',
                    'initialdate': datetime.datetime.utcnow(),
                    'status': enums.statuts.AVENIR,
                    'patientid': 1647418052,
                },
                'update': {
                    'type': 'bdiicjafbj',
                    'initialdate': datetime.datetime.utcnow(),
                    'status': enums.statuts.AVENIR,
                    'patientid': 1647418052,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.booster_shotsUpdateManyMutationInput,
        where: types.booster_shotsWhereInput,
    ) -> int:
        """Update multiple booster_shots records

        Parameters
        ----------
        data
            booster_shots data to update the selected booster_shots records to
        where
            Filter to select the booster_shots records to update

        Returns
        -------
        int
            The total number of booster_shots records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all booster_shots records
        total = await booster_shots.prisma().update_many(
            data={
                'patientid': 744964398
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.booster_shotsWhereInput] = None,
        cursor: Optional[types.booster_shotsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of booster_shots records present in the database

        Parameters
        ----------
        select
            Select the booster_shots fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            booster_shots filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.booster_shotsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await booster_shots.prisma().count()

        # results: prisma.types.booster_shotsCountAggregateOutput
        results = await booster_shots.prisma().count(
            select={
                '_all': True,
                'boostershotid': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.booster_shotsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.booster_shotsWhereInput] = None,
        cursor: Optional[types.booster_shotsWhereUniqueInput] = None,
    ) -> types.booster_shotsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.booster_shotsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.booster_shotsWhereInput] = None,
        cursor: Optional[types.booster_shotsWhereUniqueInput] = None,
    ) -> Union[int, types.booster_shotsCountAggregateOutput]:
        """Count the number of booster_shots records present in the database

        Parameters
        ----------
        select
            Select the booster_shots fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            booster_shots filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.booster_shotsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await booster_shots.prisma().count()

        # results: prisma.types.booster_shotsCountAggregateOutput
        results = await booster_shots.prisma().count(
            select={
                '_all': True,
                'type': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.booster_shotsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.booster_shotsWhereInput] = None
    ) -> int:
        """Delete multiple booster_shots records.

        Parameters
        ----------
        where
            Optional booster_shots filter to find the records to be deleted

        Returns
        -------
        int
            The total number of booster_shots records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all booster_shots records
        total = await booster_shots.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.booster_shotsScalarFieldKeys'],
        *,
        where: Optional['types.booster_shotsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.booster_shotsAvgAggregateInput'] = None,
        sum: Optional['types.booster_shotsSumAggregateInput'] = None,
        min: Optional['types.booster_shotsMinAggregateInput'] = None,
        max: Optional['types.booster_shotsMaxAggregateInput'] = None,
        having: Optional['types.booster_shotsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.booster_shotsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.booster_shotsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.booster_shotsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.booster_shotsGroupByOutput']:
        """Group booster_shots records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar booster_shots fields to group records by
        where
            booster_shots filter to select records
        take
            Limit the maximum number of booster_shots records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.booster_shotsGroupByOutput]
            A list of dictionaries representing the booster_shots record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group booster_shots records by initialdate values
        # and count how many records are in each group
        results = await booster_shots.prisma().group_by(
            ['initialdate'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class clientsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.clients]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await clients.prisma().query_raw(
            'SELECT * FROM clients WHERE clientid = $1',
            1969681615,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.clients
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await clients.prisma().query_first(
            'SELECT * FROM clients WHERE lastname = $1',
            'bbbgbhfjge',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.clientsCreateInput,
        include: Optional[types.clientsInclude] = None
    ) -> _PrismaModelT:
        """Create a new clients record.

        Parameters
        ----------
        data
            clients record data
        include
            Specifies which relations should be loaded on the returned clients model

        Returns
        -------
        prisma.models.clients
            The created clients record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a clients record from just the required fields
        clients = await clients.prisma().create(
            data={
                # data to create a clients record
                'lastname': 'igbehcbab',
                'firstname': 'bdadaadhag',
                'gender': enums.genders.M,
                'phonenumber': 'bgiggdidbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.clientsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple clients records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of clients record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await clients.prisma().create_many(
            data=[
                {
                    # data to create a clients record
                    'lastname': 'caaaedabfc',
                    'firstname': 'bigibebcib',
                    'gender': enums.genders.M,
                    'phonenumber': 'bigaiehgcc',
                },
                {
                    # data to create a clients record
                    'lastname': 'beeifcbebf',
                    'firstname': 'bgcigfahea',
                    'gender': enums.genders.M,
                    'phonenumber': 'bcejgaggif',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.clientsWhereUniqueInput,
        include: Optional[types.clientsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single clients record.

        Parameters
        ----------
        where
            clients filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned clients model

        Returns
        -------
        prisma.models.clients
            The deleted clients record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clients = await clients.prisma().delete(
            where={
                'clientid': 835903122,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.clientsWhereUniqueInput,
        include: Optional[types.clientsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique clients record.

        Parameters
        ----------
        where
            clients filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned clients model

        Returns
        -------
        prisma.models.clients
            The found clients record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clients = await clients.prisma().find_unique(
            where={
                'clientid': 763719779,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.clientsWhereUniqueInput,
        include: Optional[types.clientsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique clients record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            clients filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned clients model

        Returns
        -------
        prisma.models.clients
            The found clients record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clients = await clients.prisma().find_unique_or_raise(
            where={
                'clientid': 429995104,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.clientsWhereInput] = None,
        cursor: Optional[types.clientsWhereUniqueInput] = None,
        include: Optional[types.clientsInclude] = None,
        order: Optional[Union[types.clientsOrderByInput, List[types.clientsOrderByInput]]] = None,
        distinct: Optional[List[types.clientsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple clients records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of clients records returned
        skip
            Ignore the first N results
        where
            clients filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned clients model
        order
            Order the returned clients records by any field
        distinct
            Filter clients records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.clients]
            The list of all clients records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 clients records
        clients = await clients.prisma().find_many(take=10)

        # find the first 5 clients records ordered by the firstname field
        clients = await clients.prisma().find_many(
            take=5,
            order={
                'firstname': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.clientsWhereInput] = None,
        cursor: Optional[types.clientsWhereUniqueInput] = None,
        include: Optional[types.clientsInclude] = None,
        order: Optional[Union[types.clientsOrderByInput, List[types.clientsOrderByInput]]] = None,
        distinct: Optional[List[types.clientsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single clients record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            clients filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned clients model
        order
            Order the returned clients records by any field
        distinct
            Filter clients records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.clients
            The first clients record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second clients record ordered by the gender field
        clients = await clients.prisma().find_first(
            skip=1,
            order={
                'gender': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.clientsWhereInput] = None,
        cursor: Optional[types.clientsWhereUniqueInput] = None,
        include: Optional[types.clientsInclude] = None,
        order: Optional[Union[types.clientsOrderByInput, List[types.clientsOrderByInput]]] = None,
        distinct: Optional[List[types.clientsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single clients record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            clients filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned clients model
        order
            Order the returned clients records by any field
        distinct
            Filter clients records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.clients
            The first clients record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second clients record ordered by the phonenumber field
        clients = await clients.prisma().find_first_or_raise(
            skip=1,
            order={
                'phonenumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.clientsUpdateInput,
        where: types.clientsWhereUniqueInput,
        include: Optional[types.clientsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single clients record.

        Parameters
        ----------
        data
            clients record data specifying what to update
        where
            clients filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned clients model

        Returns
        -------
        prisma.models.clients
            The updated clients record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        clients = await clients.prisma().update(
            where={
                'clientid': 1775811865,
            },
            data={
                # data to update the clients record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.clientsWhereUniqueInput,
        data: types.clientsUpsertInput,
        include: Optional[types.clientsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            clients filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned clients model

        Returns
        -------
        prisma.models.clients
            The created or updated clients record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clients = await clients.prisma().upsert(
            where={
                'clientid': 893145566,
            },
            data={
                'create': {
                    'clientid': 893145566,
                    'lastname': 'beeifcbebf',
                    'firstname': 'bgcigfahea',
                    'gender': enums.genders.M,
                    'phonenumber': 'bcejgaggif',
                },
                'update': {
                    'lastname': 'beeifcbebf',
                    'firstname': 'bgcigfahea',
                    'gender': enums.genders.M,
                    'phonenumber': 'bcejgaggif',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.clientsUpdateManyMutationInput,
        where: types.clientsWhereInput,
    ) -> int:
        """Update multiple clients records

        Parameters
        ----------
        data
            clients data to update the selected clients records to
        where
            Filter to select the clients records to update

        Returns
        -------
        int
            The total number of clients records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all clients records
        total = await clients.prisma().update_many(
            data={
                'email': 'jjfeafhfj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.clientsWhereInput] = None,
        cursor: Optional[types.clientsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of clients records present in the database

        Parameters
        ----------
        select
            Select the clients fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            clients filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.clientsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await clients.prisma().count()

        # results: prisma.types.clientsCountAggregateOutput
        results = await clients.prisma().count(
            select={
                '_all': True,
                'address': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.clientsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.clientsWhereInput] = None,
        cursor: Optional[types.clientsWhereUniqueInput] = None,
    ) -> types.clientsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.clientsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.clientsWhereInput] = None,
        cursor: Optional[types.clientsWhereUniqueInput] = None,
    ) -> Union[int, types.clientsCountAggregateOutput]:
        """Count the number of clients records present in the database

        Parameters
        ----------
        select
            Select the clients fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            clients filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.clientsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await clients.prisma().count()

        # results: prisma.types.clientsCountAggregateOutput
        results = await clients.prisma().count(
            select={
                '_all': True,
                'zipcode': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.clientsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.clientsWhereInput] = None
    ) -> int:
        """Delete multiple clients records.

        Parameters
        ----------
        where
            Optional clients filter to find the records to be deleted

        Returns
        -------
        int
            The total number of clients records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all clients records
        total = await clients.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.clientsScalarFieldKeys'],
        *,
        where: Optional['types.clientsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.clientsAvgAggregateInput'] = None,
        sum: Optional['types.clientsSumAggregateInput'] = None,
        min: Optional['types.clientsMinAggregateInput'] = None,
        max: Optional['types.clientsMaxAggregateInput'] = None,
        having: Optional['types.clientsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.clientsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.clientsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.clientsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.clientsGroupByOutput']:
        """Group clients records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar clients fields to group records by
        where
            clients filter to select records
        take
            Limit the maximum number of clients records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.clientsGroupByOutput]
            A list of dictionaries representing the clients record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group clients records by city values
        # and count how many records are in each group
        results = await clients.prisma().group_by(
            ['city'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class earningsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.earnings]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await earnings.prisma().query_raw(
            'SELECT * FROM earnings WHERE earningid = $1',
            2102736524,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.earnings
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await earnings.prisma().query_first(
            'SELECT * FROM earnings WHERE amount = $1',
            Decimal('271520213.45663'),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.earningsCreateInput,
        include: Optional[types.earningsInclude] = None
    ) -> _PrismaModelT:
        """Create a new earnings record.

        Parameters
        ----------
        data
            earnings record data
        include
            Specifies which relations should be loaded on the returned earnings model

        Returns
        -------
        prisma.models.earnings
            The created earnings record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a earnings record from just the required fields
        earnings = await earnings.prisma().create(
            data={
                # data to create a earnings record
                'amount': Decimal('2058258651.158368'),
                'clientid': 878442065,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.earningsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple earnings records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of earnings record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await earnings.prisma().create_many(
            data=[
                {
                    # data to create a earnings record
                    'amount': Decimal('1675280054.162757'),
                    'clientid': 2054802212,
                },
                {
                    # data to create a earnings record
                    'amount': Decimal('60335757.68446'),
                    'clientid': 1625503827,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.earningsWhereUniqueInput,
        include: Optional[types.earningsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single earnings record.

        Parameters
        ----------
        where
            earnings filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned earnings model

        Returns
        -------
        prisma.models.earnings
            The deleted earnings record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        earnings = await earnings.prisma().delete(
            where={
                'earningid': 521827728,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.earningsWhereUniqueInput,
        include: Optional[types.earningsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique earnings record.

        Parameters
        ----------
        where
            earnings filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned earnings model

        Returns
        -------
        prisma.models.earnings
            The found earnings record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        earnings = await earnings.prisma().find_unique(
            where={
                'earningid': 1266032265,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.earningsWhereUniqueInput,
        include: Optional[types.earningsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique earnings record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            earnings filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned earnings model

        Returns
        -------
        prisma.models.earnings
            The found earnings record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        earnings = await earnings.prisma().find_unique_or_raise(
            where={
                'earningid': 93253262,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.earningsWhereInput] = None,
        cursor: Optional[types.earningsWhereUniqueInput] = None,
        include: Optional[types.earningsInclude] = None,
        order: Optional[Union[types.earningsOrderByInput, List[types.earningsOrderByInput]]] = None,
        distinct: Optional[List[types.earningsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple earnings records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of earnings records returned
        skip
            Ignore the first N results
        where
            earnings filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned earnings model
        order
            Order the returned earnings records by any field
        distinct
            Filter earnings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.earnings]
            The list of all earnings records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 earnings records
        earnings = await earnings.prisma().find_many(take=10)

        # find the first 5 earnings records ordered by the description field
        earnings = await earnings.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.earningsWhereInput] = None,
        cursor: Optional[types.earningsWhereUniqueInput] = None,
        include: Optional[types.earningsInclude] = None,
        order: Optional[Union[types.earningsOrderByInput, List[types.earningsOrderByInput]]] = None,
        distinct: Optional[List[types.earningsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single earnings record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            earnings filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned earnings model
        order
            Order the returned earnings records by any field
        distinct
            Filter earnings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.earnings
            The first earnings record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second earnings record ordered by the created_at field
        earnings = await earnings.prisma().find_first(
            skip=1,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.earningsWhereInput] = None,
        cursor: Optional[types.earningsWhereUniqueInput] = None,
        include: Optional[types.earningsInclude] = None,
        order: Optional[Union[types.earningsOrderByInput, List[types.earningsOrderByInput]]] = None,
        distinct: Optional[List[types.earningsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single earnings record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            earnings filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned earnings model
        order
            Order the returned earnings records by any field
        distinct
            Filter earnings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.earnings
            The first earnings record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second earnings record ordered by the paymentstatus field
        earnings = await earnings.prisma().find_first_or_raise(
            skip=1,
            order={
                'paymentstatus': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.earningsUpdateInput,
        where: types.earningsWhereUniqueInput,
        include: Optional[types.earningsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single earnings record.

        Parameters
        ----------
        data
            earnings record data specifying what to update
        where
            earnings filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned earnings model

        Returns
        -------
        prisma.models.earnings
            The updated earnings record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        earnings = await earnings.prisma().update(
            where={
                'earningid': 2053047983,
            },
            data={
                # data to update the earnings record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.earningsWhereUniqueInput,
        data: types.earningsUpsertInput,
        include: Optional[types.earningsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            earnings filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned earnings model

        Returns
        -------
        prisma.models.earnings
            The created or updated earnings record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        earnings = await earnings.prisma().upsert(
            where={
                'earningid': 685333180,
            },
            data={
                'create': {
                    'earningid': 685333180,
                    'amount': Decimal('60335757.68446'),
                    'clientid': 1625503827,
                },
                'update': {
                    'amount': Decimal('60335757.68446'),
                    'clientid': 1625503827,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.earningsUpdateManyMutationInput,
        where: types.earningsWhereInput,
    ) -> int:
        """Update multiple earnings records

        Parameters
        ----------
        data
            earnings data to update the selected earnings records to
        where
            Filter to select the earnings records to update

        Returns
        -------
        int
            The total number of earnings records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all earnings records
        total = await earnings.prisma().update_many(
            data={
                'clientid': 127474245
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.earningsWhereInput] = None,
        cursor: Optional[types.earningsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of earnings records present in the database

        Parameters
        ----------
        select
            Select the earnings fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            earnings filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.earningsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await earnings.prisma().count()

        # results: prisma.types.earningsCountAggregateOutput
        results = await earnings.prisma().count(
            select={
                '_all': True,
                'earningid': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.earningsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.earningsWhereInput] = None,
        cursor: Optional[types.earningsWhereUniqueInput] = None,
    ) -> types.earningsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.earningsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.earningsWhereInput] = None,
        cursor: Optional[types.earningsWhereUniqueInput] = None,
    ) -> Union[int, types.earningsCountAggregateOutput]:
        """Count the number of earnings records present in the database

        Parameters
        ----------
        select
            Select the earnings fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            earnings filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.earningsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await earnings.prisma().count()

        # results: prisma.types.earningsCountAggregateOutput
        results = await earnings.prisma().count(
            select={
                '_all': True,
                'amount': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.earningsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.earningsWhereInput] = None
    ) -> int:
        """Delete multiple earnings records.

        Parameters
        ----------
        where
            Optional earnings filter to find the records to be deleted

        Returns
        -------
        int
            The total number of earnings records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all earnings records
        total = await earnings.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.earningsScalarFieldKeys'],
        *,
        where: Optional['types.earningsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.earningsAvgAggregateInput'] = None,
        sum: Optional['types.earningsSumAggregateInput'] = None,
        min: Optional['types.earningsMinAggregateInput'] = None,
        max: Optional['types.earningsMaxAggregateInput'] = None,
        having: Optional['types.earningsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.earningsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.earningsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.earningsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.earningsGroupByOutput']:
        """Group earnings records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar earnings fields to group records by
        where
            earnings filter to select records
        take
            Limit the maximum number of earnings records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.earningsGroupByOutput]
            A list of dictionaries representing the earnings record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group earnings records by description values
        # and count how many records are in each group
        results = await earnings.prisma().group_by(
            ['description'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class eventsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.events]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await events.prisma().query_raw(
            'SELECT * FROM events WHERE eventid = $1',
            948921754,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.events
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await events.prisma().query_first(
            'SELECT * FROM events WHERE title = $1',
            'bjgejjabff',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.eventsCreateInput,
        include: Optional[types.eventsInclude] = None
    ) -> _PrismaModelT:
        """Create a new events record.

        Parameters
        ----------
        data
            events record data
        include
            Specifies which relations should be loaded on the returned events model

        Returns
        -------
        prisma.models.events
            The created events record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a events record from just the required fields
        events = await events.prisma().create(
            data={
                # data to create a events record
                'title': 'bcciijbibg',
                'type': enums.event_type.RENDEZVOUS,
                'eventdate': datetime.datetime.utcnow(),
                'starthour': datetime.datetime.utcnow(),
                'endhour': datetime.datetime.utcnow(),
                'status': enums.statuts.AVENIR,
                'userid': 255202753,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.eventsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple events records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of events record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await events.prisma().create_many(
            data=[
                {
                    # data to create a events record
                    'title': 'bccdfhdigc',
                    'type': enums.event_type.RENDEZVOUS,
                    'eventdate': datetime.datetime.utcnow(),
                    'starthour': datetime.datetime.utcnow(),
                    'endhour': datetime.datetime.utcnow(),
                    'status': enums.statuts.AVENIR,
                    'userid': 541269159,
                },
                {
                    # data to create a events record
                    'title': 'bageiegghg',
                    'type': enums.event_type.RENDEZVOUS,
                    'eventdate': datetime.datetime.utcnow(),
                    'starthour': datetime.datetime.utcnow(),
                    'endhour': datetime.datetime.utcnow(),
                    'status': enums.statuts.AVENIR,
                    'userid': 508382461,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.eventsWhereUniqueInput,
        include: Optional[types.eventsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single events record.

        Parameters
        ----------
        where
            events filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned events model

        Returns
        -------
        prisma.models.events
            The deleted events record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        events = await events.prisma().delete(
            where={
                'eventid': 1024265714,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.eventsWhereUniqueInput,
        include: Optional[types.eventsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique events record.

        Parameters
        ----------
        where
            events filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned events model

        Returns
        -------
        prisma.models.events
            The found events record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        events = await events.prisma().find_unique(
            where={
                'eventid': 872078403,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.eventsWhereUniqueInput,
        include: Optional[types.eventsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique events record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            events filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned events model

        Returns
        -------
        prisma.models.events
            The found events record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        events = await events.prisma().find_unique_or_raise(
            where={
                'eventid': 1874748096,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.eventsWhereInput] = None,
        cursor: Optional[types.eventsWhereUniqueInput] = None,
        include: Optional[types.eventsInclude] = None,
        order: Optional[Union[types.eventsOrderByInput, List[types.eventsOrderByInput]]] = None,
        distinct: Optional[List[types.eventsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple events records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of events records returned
        skip
            Ignore the first N results
        where
            events filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned events model
        order
            Order the returned events records by any field
        distinct
            Filter events records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.events]
            The list of all events records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 events records
        events = await events.prisma().find_many(take=10)

        # find the first 5 events records ordered by the description field
        events = await events.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.eventsWhereInput] = None,
        cursor: Optional[types.eventsWhereUniqueInput] = None,
        include: Optional[types.eventsInclude] = None,
        order: Optional[Union[types.eventsOrderByInput, List[types.eventsOrderByInput]]] = None,
        distinct: Optional[List[types.eventsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single events record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            events filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned events model
        order
            Order the returned events records by any field
        distinct
            Filter events records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.events
            The first events record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second events record ordered by the type field
        events = await events.prisma().find_first(
            skip=1,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.eventsWhereInput] = None,
        cursor: Optional[types.eventsWhereUniqueInput] = None,
        include: Optional[types.eventsInclude] = None,
        order: Optional[Union[types.eventsOrderByInput, List[types.eventsOrderByInput]]] = None,
        distinct: Optional[List[types.eventsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single events record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            events filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned events model
        order
            Order the returned events records by any field
        distinct
            Filter events records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.events
            The first events record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second events record ordered by the eventdate field
        events = await events.prisma().find_first_or_raise(
            skip=1,
            order={
                'eventdate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.eventsUpdateInput,
        where: types.eventsWhereUniqueInput,
        include: Optional[types.eventsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single events record.

        Parameters
        ----------
        data
            events record data specifying what to update
        where
            events filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned events model

        Returns
        -------
        prisma.models.events
            The updated events record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        events = await events.prisma().update(
            where={
                'eventid': 916896761,
            },
            data={
                # data to update the events record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.eventsWhereUniqueInput,
        data: types.eventsUpsertInput,
        include: Optional[types.eventsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            events filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned events model

        Returns
        -------
        prisma.models.events
            The created or updated events record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        events = await events.prisma().upsert(
            where={
                'eventid': 769267518,
            },
            data={
                'create': {
                    'eventid': 769267518,
                    'title': 'bageiegghg',
                    'type': enums.event_type.RENDEZVOUS,
                    'eventdate': datetime.datetime.utcnow(),
                    'starthour': datetime.datetime.utcnow(),
                    'endhour': datetime.datetime.utcnow(),
                    'status': enums.statuts.AVENIR,
                    'userid': 508382461,
                },
                'update': {
                    'title': 'bageiegghg',
                    'type': enums.event_type.RENDEZVOUS,
                    'eventdate': datetime.datetime.utcnow(),
                    'starthour': datetime.datetime.utcnow(),
                    'endhour': datetime.datetime.utcnow(),
                    'status': enums.statuts.AVENIR,
                    'userid': 508382461,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.eventsUpdateManyMutationInput,
        where: types.eventsWhereInput,
    ) -> int:
        """Update multiple events records

        Parameters
        ----------
        data
            events data to update the selected events records to
        where
            Filter to select the events records to update

        Returns
        -------
        int
            The total number of events records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all events records
        total = await events.prisma().update_many(
            data={
                'starthour': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.eventsWhereInput] = None,
        cursor: Optional[types.eventsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of events records present in the database

        Parameters
        ----------
        select
            Select the events fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            events filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.eventsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await events.prisma().count()

        # results: prisma.types.eventsCountAggregateOutput
        results = await events.prisma().count(
            select={
                '_all': True,
                'endhour': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.eventsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.eventsWhereInput] = None,
        cursor: Optional[types.eventsWhereUniqueInput] = None,
    ) -> types.eventsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.eventsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.eventsWhereInput] = None,
        cursor: Optional[types.eventsWhereUniqueInput] = None,
    ) -> Union[int, types.eventsCountAggregateOutput]:
        """Count the number of events records present in the database

        Parameters
        ----------
        select
            Select the events fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            events filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.eventsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await events.prisma().count()

        # results: prisma.types.eventsCountAggregateOutput
        results = await events.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.eventsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.eventsWhereInput] = None
    ) -> int:
        """Delete multiple events records.

        Parameters
        ----------
        where
            Optional events filter to find the records to be deleted

        Returns
        -------
        int
            The total number of events records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all events records
        total = await events.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.eventsScalarFieldKeys'],
        *,
        where: Optional['types.eventsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.eventsAvgAggregateInput'] = None,
        sum: Optional['types.eventsSumAggregateInput'] = None,
        min: Optional['types.eventsMinAggregateInput'] = None,
        max: Optional['types.eventsMaxAggregateInput'] = None,
        having: Optional['types.eventsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.eventsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.eventsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.eventsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.eventsGroupByOutput']:
        """Group events records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar events fields to group records by
        where
            events filter to select records
        take
            Limit the maximum number of events records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.eventsGroupByOutput]
            A list of dictionaries representing the events record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group events records by userid values
        # and count how many records are in each group
        results = await events.prisma().group_by(
            ['userid'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class expensesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.expenses]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await expenses.prisma().query_raw(
            'SELECT * FROM expenses WHERE expenseid = $1',
            820312479,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.expenses
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await expenses.prisma().query_first(
            'SELECT * FROM expenses WHERE amount = $1',
            Decimal('92728044.34485'),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.expensesCreateInput,
        include: Optional[types.expensesInclude] = None
    ) -> _PrismaModelT:
        """Create a new expenses record.

        Parameters
        ----------
        data
            expenses record data
        include
            Specifies which relations should be loaded on the returned expenses model

        Returns
        -------
        prisma.models.expenses
            The created expenses record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a expenses record from just the required fields
        expenses = await expenses.prisma().create(
            data={
                # data to create a expenses record
                'amount': Decimal('1121741130.149589'),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.expensesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple expenses records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of expenses record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await expenses.prisma().create_many(
            data=[
                {
                    # data to create a expenses record
                    'amount': Decimal('208521688.86081'),
                },
                {
                    # data to create a expenses record
                    'amount': Decimal('1660932118.52576'),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.expensesWhereUniqueInput,
        include: Optional[types.expensesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single expenses record.

        Parameters
        ----------
        where
            expenses filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned expenses model

        Returns
        -------
        prisma.models.expenses
            The deleted expenses record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        expenses = await expenses.prisma().delete(
            where={
                'expenseid': 736209796,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.expensesWhereUniqueInput,
        include: Optional[types.expensesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique expenses record.

        Parameters
        ----------
        where
            expenses filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned expenses model

        Returns
        -------
        prisma.models.expenses
            The found expenses record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        expenses = await expenses.prisma().find_unique(
            where={
                'expenseid': 493907821,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.expensesWhereUniqueInput,
        include: Optional[types.expensesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique expenses record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            expenses filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned expenses model

        Returns
        -------
        prisma.models.expenses
            The found expenses record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        expenses = await expenses.prisma().find_unique_or_raise(
            where={
                'expenseid': 639686562,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.expensesWhereInput] = None,
        cursor: Optional[types.expensesWhereUniqueInput] = None,
        include: Optional[types.expensesInclude] = None,
        order: Optional[Union[types.expensesOrderByInput, List[types.expensesOrderByInput]]] = None,
        distinct: Optional[List[types.expensesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple expenses records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of expenses records returned
        skip
            Ignore the first N results
        where
            expenses filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned expenses model
        order
            Order the returned expenses records by any field
        distinct
            Filter expenses records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.expenses]
            The list of all expenses records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 expenses records
        expenses = await expenses.prisma().find_many(take=10)

        # find the first 5 expenses records ordered by the description field
        expenses = await expenses.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.expensesWhereInput] = None,
        cursor: Optional[types.expensesWhereUniqueInput] = None,
        include: Optional[types.expensesInclude] = None,
        order: Optional[Union[types.expensesOrderByInput, List[types.expensesOrderByInput]]] = None,
        distinct: Optional[List[types.expensesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single expenses record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            expenses filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned expenses model
        order
            Order the returned expenses records by any field
        distinct
            Filter expenses records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.expenses
            The first expenses record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second expenses record ordered by the created_at field
        expenses = await expenses.prisma().find_first(
            skip=1,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.expensesWhereInput] = None,
        cursor: Optional[types.expensesWhereUniqueInput] = None,
        include: Optional[types.expensesInclude] = None,
        order: Optional[Union[types.expensesOrderByInput, List[types.expensesOrderByInput]]] = None,
        distinct: Optional[List[types.expensesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single expenses record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            expenses filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned expenses model
        order
            Order the returned expenses records by any field
        distinct
            Filter expenses records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.expenses
            The first expenses record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second expenses record ordered by the expenseid field
        expenses = await expenses.prisma().find_first_or_raise(
            skip=1,
            order={
                'expenseid': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.expensesUpdateInput,
        where: types.expensesWhereUniqueInput,
        include: Optional[types.expensesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single expenses record.

        Parameters
        ----------
        data
            expenses record data specifying what to update
        where
            expenses filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned expenses model

        Returns
        -------
        prisma.models.expenses
            The updated expenses record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        expenses = await expenses.prisma().update(
            where={
                'expenseid': 654007347,
            },
            data={
                # data to update the expenses record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.expensesWhereUniqueInput,
        data: types.expensesUpsertInput,
        include: Optional[types.expensesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            expenses filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned expenses model

        Returns
        -------
        prisma.models.expenses
            The created or updated expenses record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        expenses = await expenses.prisma().upsert(
            where={
                'expenseid': 1905261552,
            },
            data={
                'create': {
                    'expenseid': 1905261552,
                    'amount': Decimal('1660932118.52576'),
                },
                'update': {
                    'amount': Decimal('1660932118.52576'),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.expensesUpdateManyMutationInput,
        where: types.expensesWhereInput,
    ) -> int:
        """Update multiple expenses records

        Parameters
        ----------
        data
            expenses data to update the selected expenses records to
        where
            Filter to select the expenses records to update

        Returns
        -------
        int
            The total number of expenses records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all expenses records
        total = await expenses.prisma().update_many(
            data={
                'amount': Decimal('78746985.139832')
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.expensesWhereInput] = None,
        cursor: Optional[types.expensesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of expenses records present in the database

        Parameters
        ----------
        select
            Select the expenses fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            expenses filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.expensesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await expenses.prisma().count()

        # results: prisma.types.expensesCountAggregateOutput
        results = await expenses.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.expensesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.expensesWhereInput] = None,
        cursor: Optional[types.expensesWhereUniqueInput] = None,
    ) -> types.expensesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.expensesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.expensesWhereInput] = None,
        cursor: Optional[types.expensesWhereUniqueInput] = None,
    ) -> Union[int, types.expensesCountAggregateOutput]:
        """Count the number of expenses records present in the database

        Parameters
        ----------
        select
            Select the expenses fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            expenses filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.expensesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await expenses.prisma().count()

        # results: prisma.types.expensesCountAggregateOutput
        results = await expenses.prisma().count(
            select={
                '_all': True,
                'created_at': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.expensesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.expensesWhereInput] = None
    ) -> int:
        """Delete multiple expenses records.

        Parameters
        ----------
        where
            Optional expenses filter to find the records to be deleted

        Returns
        -------
        int
            The total number of expenses records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all expenses records
        total = await expenses.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.expensesScalarFieldKeys'],
        *,
        where: Optional['types.expensesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.expensesAvgAggregateInput'] = None,
        sum: Optional['types.expensesSumAggregateInput'] = None,
        min: Optional['types.expensesMinAggregateInput'] = None,
        max: Optional['types.expensesMaxAggregateInput'] = None,
        having: Optional['types.expensesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.expensesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.expensesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.expensesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.expensesGroupByOutput']:
        """Group expenses records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar expenses fields to group records by
        where
            expenses filter to select records
        take
            Limit the maximum number of expenses records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.expensesGroupByOutput]
            A list of dictionaries representing the expenses record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group expenses records by expenseid values
        # and count how many records are in each group
        results = await expenses.prisma().group_by(
            ['expenseid'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class invoicesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.invoices]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await invoices.prisma().query_raw(
            'SELECT * FROM invoices WHERE invoiceid = $1',
            856000655,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.invoices
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await invoices.prisma().query_first(
            'SELECT * FROM invoices WHERE amount = $1',
            Decimal('1452336924.157319'),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.invoicesCreateInput,
        include: Optional[types.invoicesInclude] = None
    ) -> _PrismaModelT:
        """Create a new invoices record.

        Parameters
        ----------
        data
            invoices record data
        include
            Specifies which relations should be loaded on the returned invoices model

        Returns
        -------
        prisma.models.invoices
            The created invoices record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a invoices record from just the required fields
        invoices = await invoices.prisma().create(
            data={
                # data to create a invoices record
                'amount': Decimal('2013903098.50096'),
                'invoicelink': 'biaagcedjc',
                'clientid': 2077067425,
                'earningid': 1672112838,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.invoicesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple invoices records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of invoices record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await invoices.prisma().create_many(
            data=[
                {
                    # data to create a invoices record
                    'amount': Decimal('926677639.144762'),
                    'invoicelink': 'bhdiaidiaf',
                    'clientid': 340946258,
                    'earningid': 601077795,
                },
                {
                    # data to create a invoices record
                    'amount': Decimal('290603296.185582'),
                    'invoicelink': 'bgbbaajbic',
                    'clientid': 446673791,
                    'earningid': 300568396,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.invoicesWhereUniqueInput,
        include: Optional[types.invoicesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single invoices record.

        Parameters
        ----------
        where
            invoices filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned invoices model

        Returns
        -------
        prisma.models.invoices
            The deleted invoices record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        invoices = await invoices.prisma().delete(
            where={
                'invoiceid': 632626069,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.invoicesWhereUniqueInput,
        include: Optional[types.invoicesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique invoices record.

        Parameters
        ----------
        where
            invoices filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned invoices model

        Returns
        -------
        prisma.models.invoices
            The found invoices record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        invoices = await invoices.prisma().find_unique(
            where={
                'invoiceid': 1724011690,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.invoicesWhereUniqueInput,
        include: Optional[types.invoicesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique invoices record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            invoices filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned invoices model

        Returns
        -------
        prisma.models.invoices
            The found invoices record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        invoices = await invoices.prisma().find_unique_or_raise(
            where={
                'invoiceid': 470157467,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.invoicesWhereInput] = None,
        cursor: Optional[types.invoicesWhereUniqueInput] = None,
        include: Optional[types.invoicesInclude] = None,
        order: Optional[Union[types.invoicesOrderByInput, List[types.invoicesOrderByInput]]] = None,
        distinct: Optional[List[types.invoicesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple invoices records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of invoices records returned
        skip
            Ignore the first N results
        where
            invoices filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned invoices model
        order
            Order the returned invoices records by any field
        distinct
            Filter invoices records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.invoices]
            The list of all invoices records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 invoices records
        invoices = await invoices.prisma().find_many(take=10)

        # find the first 5 invoices records ordered by the invoicelink field
        invoices = await invoices.prisma().find_many(
            take=5,
            order={
                'invoicelink': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.invoicesWhereInput] = None,
        cursor: Optional[types.invoicesWhereUniqueInput] = None,
        include: Optional[types.invoicesInclude] = None,
        order: Optional[Union[types.invoicesOrderByInput, List[types.invoicesOrderByInput]]] = None,
        distinct: Optional[List[types.invoicesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single invoices record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            invoices filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned invoices model
        order
            Order the returned invoices records by any field
        distinct
            Filter invoices records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.invoices
            The first invoices record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second invoices record ordered by the created_at field
        invoices = await invoices.prisma().find_first(
            skip=1,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.invoicesWhereInput] = None,
        cursor: Optional[types.invoicesWhereUniqueInput] = None,
        include: Optional[types.invoicesInclude] = None,
        order: Optional[Union[types.invoicesOrderByInput, List[types.invoicesOrderByInput]]] = None,
        distinct: Optional[List[types.invoicesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single invoices record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            invoices filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned invoices model
        order
            Order the returned invoices records by any field
        distinct
            Filter invoices records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.invoices
            The first invoices record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second invoices record ordered by the clientid field
        invoices = await invoices.prisma().find_first_or_raise(
            skip=1,
            order={
                'clientid': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.invoicesUpdateInput,
        where: types.invoicesWhereUniqueInput,
        include: Optional[types.invoicesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single invoices record.

        Parameters
        ----------
        data
            invoices record data specifying what to update
        where
            invoices filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned invoices model

        Returns
        -------
        prisma.models.invoices
            The updated invoices record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        invoices = await invoices.prisma().update(
            where={
                'invoiceid': 1209209912,
            },
            data={
                # data to update the invoices record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.invoicesWhereUniqueInput,
        data: types.invoicesUpsertInput,
        include: Optional[types.invoicesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            invoices filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned invoices model

        Returns
        -------
        prisma.models.invoices
            The created or updated invoices record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        invoices = await invoices.prisma().upsert(
            where={
                'invoiceid': 1536744465,
            },
            data={
                'create': {
                    'invoiceid': 1536744465,
                    'amount': Decimal('290603296.185582'),
                    'invoicelink': 'bgbbaajbic',
                    'clientid': 446673791,
                    'earningid': 300568396,
                },
                'update': {
                    'amount': Decimal('290603296.185582'),
                    'invoicelink': 'bgbbaajbic',
                    'clientid': 446673791,
                    'earningid': 300568396,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.invoicesUpdateManyMutationInput,
        where: types.invoicesWhereInput,
    ) -> int:
        """Update multiple invoices records

        Parameters
        ----------
        data
            invoices data to update the selected invoices records to
        where
            Filter to select the invoices records to update

        Returns
        -------
        int
            The total number of invoices records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all invoices records
        total = await invoices.prisma().update_many(
            data={
                'earningid': 424218998
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.invoicesWhereInput] = None,
        cursor: Optional[types.invoicesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of invoices records present in the database

        Parameters
        ----------
        select
            Select the invoices fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            invoices filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.invoicesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await invoices.prisma().count()

        # results: prisma.types.invoicesCountAggregateOutput
        results = await invoices.prisma().count(
            select={
                '_all': True,
                'invoiceid': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.invoicesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.invoicesWhereInput] = None,
        cursor: Optional[types.invoicesWhereUniqueInput] = None,
    ) -> types.invoicesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.invoicesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.invoicesWhereInput] = None,
        cursor: Optional[types.invoicesWhereUniqueInput] = None,
    ) -> Union[int, types.invoicesCountAggregateOutput]:
        """Count the number of invoices records present in the database

        Parameters
        ----------
        select
            Select the invoices fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            invoices filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.invoicesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await invoices.prisma().count()

        # results: prisma.types.invoicesCountAggregateOutput
        results = await invoices.prisma().count(
            select={
                '_all': True,
                'amount': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.invoicesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.invoicesWhereInput] = None
    ) -> int:
        """Delete multiple invoices records.

        Parameters
        ----------
        where
            Optional invoices filter to find the records to be deleted

        Returns
        -------
        int
            The total number of invoices records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all invoices records
        total = await invoices.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.invoicesScalarFieldKeys'],
        *,
        where: Optional['types.invoicesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.invoicesAvgAggregateInput'] = None,
        sum: Optional['types.invoicesSumAggregateInput'] = None,
        min: Optional['types.invoicesMinAggregateInput'] = None,
        max: Optional['types.invoicesMaxAggregateInput'] = None,
        having: Optional['types.invoicesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.invoicesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.invoicesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.invoicesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.invoicesGroupByOutput']:
        """Group invoices records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar invoices fields to group records by
        where
            invoices filter to select records
        take
            Limit the maximum number of invoices records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.invoicesGroupByOutput]
            A list of dictionaries representing the invoices record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group invoices records by invoicelink values
        # and count how many records are in each group
        results = await invoices.prisma().group_by(
            ['invoicelink'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class items_boughtActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.items_bought]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await items_bought.prisma().query_raw(
            'SELECT * FROM items_bought WHERE expenseid = $1',
            2125632375,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.items_bought
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await items_bought.prisma().query_first(
            'SELECT * FROM items_bought WHERE productid = $1',
            536951780,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.items_boughtCreateInput,
        include: Optional[types.items_boughtInclude] = None
    ) -> _PrismaModelT:
        """Create a new items_bought record.

        Parameters
        ----------
        data
            items_bought record data
        include
            Specifies which relations should be loaded on the returned items_bought model

        Returns
        -------
        prisma.models.items_bought
            The created items_bought record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a items_bought record from just the required fields
        items_bought = await items_bought.prisma().create(
            data={
                # data to create a items_bought record
                'expenseid': 924723277,
                'productid': 1621937922,
                'quantity': 1848832019,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.items_boughtCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple items_bought records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of items_bought record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await items_bought.prisma().create_many(
            data=[
                {
                    # data to create a items_bought record
                    'expenseid': 1921528400,
                    'productid': 2100427849,
                    'quantity': 849140046,
                },
                {
                    # data to create a items_bought record
                    'expenseid': 928152175,
                    'productid': 273032060,
                    'quantity': 982848517,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.items_boughtWhereUniqueInput,
        include: Optional[types.items_boughtInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single items_bought record.

        Parameters
        ----------
        where
            items_bought filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned items_bought model

        Returns
        -------
        prisma.models.items_bought
            The deleted items_bought record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        items_bought = await items_bought.prisma().delete(
            where={
                # items_bought where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.items_boughtWhereUniqueInput,
        include: Optional[types.items_boughtInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique items_bought record.

        Parameters
        ----------
        where
            items_bought filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned items_bought model

        Returns
        -------
        prisma.models.items_bought
            The found items_bought record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        items_bought = await items_bought.prisma().find_unique(
            where={
                # items_bought where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.items_boughtWhereUniqueInput,
        include: Optional[types.items_boughtInclude] = None
    ) -> _PrismaModelT:
        """Find a unique items_bought record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            items_bought filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned items_bought model

        Returns
        -------
        prisma.models.items_bought
            The found items_bought record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        items_bought = await items_bought.prisma().find_unique_or_raise(
            where={
                # items_bought where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.items_boughtWhereInput] = None,
        cursor: Optional[types.items_boughtWhereUniqueInput] = None,
        include: Optional[types.items_boughtInclude] = None,
        order: Optional[Union[types.items_boughtOrderByInput, List[types.items_boughtOrderByInput]]] = None,
        distinct: Optional[List[types.items_boughtScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple items_bought records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of items_bought records returned
        skip
            Ignore the first N results
        where
            items_bought filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned items_bought model
        order
            Order the returned items_bought records by any field
        distinct
            Filter items_bought records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.items_bought]
            The list of all items_bought records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 items_bought records
        items_boughts = await items_bought.prisma().find_many(take=10)

        # find the first 5 items_bought records ordered by the quantity field
        items_boughts = await items_bought.prisma().find_many(
            take=5,
            order={
                'quantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.items_boughtWhereInput] = None,
        cursor: Optional[types.items_boughtWhereUniqueInput] = None,
        include: Optional[types.items_boughtInclude] = None,
        order: Optional[Union[types.items_boughtOrderByInput, List[types.items_boughtOrderByInput]]] = None,
        distinct: Optional[List[types.items_boughtScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single items_bought record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            items_bought filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned items_bought model
        order
            Order the returned items_bought records by any field
        distinct
            Filter items_bought records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.items_bought
            The first items_bought record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second items_bought record ordered by the expenseid field
        items_bought = await items_bought.prisma().find_first(
            skip=1,
            order={
                'expenseid': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.items_boughtWhereInput] = None,
        cursor: Optional[types.items_boughtWhereUniqueInput] = None,
        include: Optional[types.items_boughtInclude] = None,
        order: Optional[Union[types.items_boughtOrderByInput, List[types.items_boughtOrderByInput]]] = None,
        distinct: Optional[List[types.items_boughtScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single items_bought record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            items_bought filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned items_bought model
        order
            Order the returned items_bought records by any field
        distinct
            Filter items_bought records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.items_bought
            The first items_bought record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second items_bought record ordered by the productid field
        items_bought = await items_bought.prisma().find_first_or_raise(
            skip=1,
            order={
                'productid': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.items_boughtUpdateInput,
        where: types.items_boughtWhereUniqueInput,
        include: Optional[types.items_boughtInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single items_bought record.

        Parameters
        ----------
        data
            items_bought record data specifying what to update
        where
            items_bought filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned items_bought model

        Returns
        -------
        prisma.models.items_bought
            The updated items_bought record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        items_bought = await items_bought.prisma().update(
            where={
                # items_bought where unique filter

            },
            data={
                # data to update the items_bought record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.items_boughtWhereUniqueInput,
        data: types.items_boughtUpsertInput,
        include: Optional[types.items_boughtInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            items_bought filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned items_bought model

        Returns
        -------
        prisma.models.items_bought
            The created or updated items_bought record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        items_bought = await items_bought.prisma().upsert(
            where={
                # items_bought where unique filter
            },
            data={
                'create': {
                    # items_bought data to be set if the record does not exist
                },
                'update': {
                    # items_bought data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.items_boughtUpdateManyMutationInput,
        where: types.items_boughtWhereInput,
    ) -> int:
        """Update multiple items_bought records

        Parameters
        ----------
        data
            items_bought data to update the selected items_bought records to
        where
            Filter to select the items_bought records to update

        Returns
        -------
        int
            The total number of items_bought records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all items_bought records
        total = await items_bought.prisma().update_many(
            data={
                'quantity': 510737498
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.items_boughtWhereInput] = None,
        cursor: Optional[types.items_boughtWhereUniqueInput] = None,
    ) -> int:
        """Count the number of items_bought records present in the database

        Parameters
        ----------
        select
            Select the items_bought fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            items_bought filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.items_boughtCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await items_bought.prisma().count()

        # results: prisma.types.items_boughtCountAggregateOutput
        results = await items_bought.prisma().count(
            select={
                '_all': True,
                'expenseid': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.items_boughtCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.items_boughtWhereInput] = None,
        cursor: Optional[types.items_boughtWhereUniqueInput] = None,
    ) -> types.items_boughtCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.items_boughtCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.items_boughtWhereInput] = None,
        cursor: Optional[types.items_boughtWhereUniqueInput] = None,
    ) -> Union[int, types.items_boughtCountAggregateOutput]:
        """Count the number of items_bought records present in the database

        Parameters
        ----------
        select
            Select the items_bought fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            items_bought filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.items_boughtCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await items_bought.prisma().count()

        # results: prisma.types.items_boughtCountAggregateOutput
        results = await items_bought.prisma().count(
            select={
                '_all': True,
                'productid': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.items_boughtCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.items_boughtWhereInput] = None
    ) -> int:
        """Delete multiple items_bought records.

        Parameters
        ----------
        where
            Optional items_bought filter to find the records to be deleted

        Returns
        -------
        int
            The total number of items_bought records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all items_bought records
        total = await items_bought.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.items_boughtScalarFieldKeys'],
        *,
        where: Optional['types.items_boughtWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.items_boughtAvgAggregateInput'] = None,
        sum: Optional['types.items_boughtSumAggregateInput'] = None,
        min: Optional['types.items_boughtMinAggregateInput'] = None,
        max: Optional['types.items_boughtMaxAggregateInput'] = None,
        having: Optional['types.items_boughtScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.items_boughtCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.items_boughtScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.items_boughtScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.items_boughtGroupByOutput']:
        """Group items_bought records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar items_bought fields to group records by
        where
            items_bought filter to select records
        take
            Limit the maximum number of items_bought records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.items_boughtGroupByOutput]
            A list of dictionaries representing the items_bought record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group items_bought records by quantity values
        # and count how many records are in each group
        results = await items_bought.prisma().group_by(
            ['quantity'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class items_soldActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.items_sold]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await items_sold.prisma().query_raw(
            'SELECT * FROM items_sold WHERE earningid = $1',
            2117488267,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.items_sold
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await items_sold.prisma().query_first(
            'SELECT * FROM items_sold WHERE productid = $1',
            1401944936,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.items_soldCreateInput,
        include: Optional[types.items_soldInclude] = None
    ) -> _PrismaModelT:
        """Create a new items_sold record.

        Parameters
        ----------
        data
            items_sold record data
        include
            Specifies which relations should be loaded on the returned items_sold model

        Returns
        -------
        prisma.models.items_sold
            The created items_sold record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a items_sold record from just the required fields
        items_sold = await items_sold.prisma().create(
            data={
                # data to create a items_sold record
                'earningid': 1297607553,
                'productid': 519488550,
                'quantity': 976832615,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.items_soldCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple items_sold records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of items_sold record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await items_sold.prisma().create_many(
            data=[
                {
                    # data to create a items_sold record
                    'earningid': 1696425492,
                    'productid': 169262781,
                    'quantity': 1023081650,
                },
                {
                    # data to create a items_sold record
                    'earningid': 327681027,
                    'productid': 527748992,
                    'quantity': 2029357497,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.items_soldWhereUniqueInput,
        include: Optional[types.items_soldInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single items_sold record.

        Parameters
        ----------
        where
            items_sold filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned items_sold model

        Returns
        -------
        prisma.models.items_sold
            The deleted items_sold record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        items_sold = await items_sold.prisma().delete(
            where={
                # items_sold where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.items_soldWhereUniqueInput,
        include: Optional[types.items_soldInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique items_sold record.

        Parameters
        ----------
        where
            items_sold filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned items_sold model

        Returns
        -------
        prisma.models.items_sold
            The found items_sold record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        items_sold = await items_sold.prisma().find_unique(
            where={
                # items_sold where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.items_soldWhereUniqueInput,
        include: Optional[types.items_soldInclude] = None
    ) -> _PrismaModelT:
        """Find a unique items_sold record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            items_sold filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned items_sold model

        Returns
        -------
        prisma.models.items_sold
            The found items_sold record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        items_sold = await items_sold.prisma().find_unique_or_raise(
            where={
                # items_sold where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.items_soldWhereInput] = None,
        cursor: Optional[types.items_soldWhereUniqueInput] = None,
        include: Optional[types.items_soldInclude] = None,
        order: Optional[Union[types.items_soldOrderByInput, List[types.items_soldOrderByInput]]] = None,
        distinct: Optional[List[types.items_soldScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple items_sold records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of items_sold records returned
        skip
            Ignore the first N results
        where
            items_sold filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned items_sold model
        order
            Order the returned items_sold records by any field
        distinct
            Filter items_sold records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.items_sold]
            The list of all items_sold records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 items_sold records
        items_solds = await items_sold.prisma().find_many(take=10)

        # find the first 5 items_sold records ordered by the quantity field
        items_solds = await items_sold.prisma().find_many(
            take=5,
            order={
                'quantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.items_soldWhereInput] = None,
        cursor: Optional[types.items_soldWhereUniqueInput] = None,
        include: Optional[types.items_soldInclude] = None,
        order: Optional[Union[types.items_soldOrderByInput, List[types.items_soldOrderByInput]]] = None,
        distinct: Optional[List[types.items_soldScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single items_sold record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            items_sold filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned items_sold model
        order
            Order the returned items_sold records by any field
        distinct
            Filter items_sold records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.items_sold
            The first items_sold record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second items_sold record ordered by the earningid field
        items_sold = await items_sold.prisma().find_first(
            skip=1,
            order={
                'earningid': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.items_soldWhereInput] = None,
        cursor: Optional[types.items_soldWhereUniqueInput] = None,
        include: Optional[types.items_soldInclude] = None,
        order: Optional[Union[types.items_soldOrderByInput, List[types.items_soldOrderByInput]]] = None,
        distinct: Optional[List[types.items_soldScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single items_sold record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            items_sold filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned items_sold model
        order
            Order the returned items_sold records by any field
        distinct
            Filter items_sold records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.items_sold
            The first items_sold record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second items_sold record ordered by the productid field
        items_sold = await items_sold.prisma().find_first_or_raise(
            skip=1,
            order={
                'productid': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.items_soldUpdateInput,
        where: types.items_soldWhereUniqueInput,
        include: Optional[types.items_soldInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single items_sold record.

        Parameters
        ----------
        data
            items_sold record data specifying what to update
        where
            items_sold filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned items_sold model

        Returns
        -------
        prisma.models.items_sold
            The updated items_sold record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        items_sold = await items_sold.prisma().update(
            where={
                # items_sold where unique filter

            },
            data={
                # data to update the items_sold record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.items_soldWhereUniqueInput,
        data: types.items_soldUpsertInput,
        include: Optional[types.items_soldInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            items_sold filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned items_sold model

        Returns
        -------
        prisma.models.items_sold
            The created or updated items_sold record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        items_sold = await items_sold.prisma().upsert(
            where={
                # items_sold where unique filter
            },
            data={
                'create': {
                    # items_sold data to be set if the record does not exist
                },
                'update': {
                    # items_sold data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.items_soldUpdateManyMutationInput,
        where: types.items_soldWhereInput,
    ) -> int:
        """Update multiple items_sold records

        Parameters
        ----------
        data
            items_sold data to update the selected items_sold records to
        where
            Filter to select the items_sold records to update

        Returns
        -------
        int
            The total number of items_sold records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all items_sold records
        total = await items_sold.prisma().update_many(
            data={
                'quantity': 1318597118
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.items_soldWhereInput] = None,
        cursor: Optional[types.items_soldWhereUniqueInput] = None,
    ) -> int:
        """Count the number of items_sold records present in the database

        Parameters
        ----------
        select
            Select the items_sold fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            items_sold filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.items_soldCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await items_sold.prisma().count()

        # results: prisma.types.items_soldCountAggregateOutput
        results = await items_sold.prisma().count(
            select={
                '_all': True,
                'earningid': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.items_soldCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.items_soldWhereInput] = None,
        cursor: Optional[types.items_soldWhereUniqueInput] = None,
    ) -> types.items_soldCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.items_soldCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.items_soldWhereInput] = None,
        cursor: Optional[types.items_soldWhereUniqueInput] = None,
    ) -> Union[int, types.items_soldCountAggregateOutput]:
        """Count the number of items_sold records present in the database

        Parameters
        ----------
        select
            Select the items_sold fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            items_sold filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.items_soldCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await items_sold.prisma().count()

        # results: prisma.types.items_soldCountAggregateOutput
        results = await items_sold.prisma().count(
            select={
                '_all': True,
                'productid': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.items_soldCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.items_soldWhereInput] = None
    ) -> int:
        """Delete multiple items_sold records.

        Parameters
        ----------
        where
            Optional items_sold filter to find the records to be deleted

        Returns
        -------
        int
            The total number of items_sold records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all items_sold records
        total = await items_sold.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.items_soldScalarFieldKeys'],
        *,
        where: Optional['types.items_soldWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.items_soldAvgAggregateInput'] = None,
        sum: Optional['types.items_soldSumAggregateInput'] = None,
        min: Optional['types.items_soldMinAggregateInput'] = None,
        max: Optional['types.items_soldMaxAggregateInput'] = None,
        having: Optional['types.items_soldScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.items_soldCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.items_soldScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.items_soldScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.items_soldGroupByOutput']:
        """Group items_sold records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar items_sold fields to group records by
        where
            items_sold filter to select records
        take
            Limit the maximum number of items_sold records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.items_soldGroupByOutput]
            A list of dictionaries representing the items_sold record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group items_sold records by quantity values
        # and count how many records are in each group
        results = await items_sold.prisma().group_by(
            ['quantity'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class patientsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.patients]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await patients.prisma().query_raw(
            'SELECT * FROM patients WHERE patientid = $1',
            2122112351,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.patients
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await patients.prisma().query_first(
            'SELECT * FROM patients WHERE name = $1',
            'bacejedaca',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.patientsCreateInput,
        include: Optional[types.patientsInclude] = None
    ) -> _PrismaModelT:
        """Create a new patients record.

        Parameters
        ----------
        data
            patients record data
        include
            Specifies which relations should be loaded on the returned patients model

        Returns
        -------
        prisma.models.patients
            The created patients record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a patients record from just the required fields
        patients = await patients.prisma().create(
            data={
                # data to create a patients record
                'name': 'bhbhdahfaj',
                'gender': enums.genders.M,
                'type': 'bfjibceaec',
                'clientid': 817623163,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.patientsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple patients records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of patients record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await patients.prisma().create_many(
            data=[
                {
                    # data to create a patients record
                    'name': 'badaffhddg',
                    'gender': enums.genders.M,
                    'type': 'bbdbfcfihd',
                    'clientid': 210666198,
                },
                {
                    # data to create a patients record
                    'name': 'bchgafhjed',
                    'gender': enums.genders.M,
                    'type': 'heffgjdei',
                    'clientid': 307876141,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.patientsWhereUniqueInput,
        include: Optional[types.patientsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single patients record.

        Parameters
        ----------
        where
            patients filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned patients model

        Returns
        -------
        prisma.models.patients
            The deleted patients record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        patients = await patients.prisma().delete(
            where={
                'patientid': 1674049122,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.patientsWhereUniqueInput,
        include: Optional[types.patientsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique patients record.

        Parameters
        ----------
        where
            patients filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned patients model

        Returns
        -------
        prisma.models.patients
            The found patients record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        patients = await patients.prisma().find_unique(
            where={
                'patientid': 1526854643,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.patientsWhereUniqueInput,
        include: Optional[types.patientsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique patients record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            patients filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned patients model

        Returns
        -------
        prisma.models.patients
            The found patients record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        patients = await patients.prisma().find_unique_or_raise(
            where={
                'patientid': 958077104,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.patientsWhereInput] = None,
        cursor: Optional[types.patientsWhereUniqueInput] = None,
        include: Optional[types.patientsInclude] = None,
        order: Optional[Union[types.patientsOrderByInput, List[types.patientsOrderByInput]]] = None,
        distinct: Optional[List[types.patientsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple patients records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of patients records returned
        skip
            Ignore the first N results
        where
            patients filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned patients model
        order
            Order the returned patients records by any field
        distinct
            Filter patients records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.patients]
            The list of all patients records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 patients records
        patients = await patients.prisma().find_many(take=10)

        # find the first 5 patients records ordered by the gender field
        patients = await patients.prisma().find_many(
            take=5,
            order={
                'gender': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.patientsWhereInput] = None,
        cursor: Optional[types.patientsWhereUniqueInput] = None,
        include: Optional[types.patientsInclude] = None,
        order: Optional[Union[types.patientsOrderByInput, List[types.patientsOrderByInput]]] = None,
        distinct: Optional[List[types.patientsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single patients record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            patients filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned patients model
        order
            Order the returned patients records by any field
        distinct
            Filter patients records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.patients
            The first patients record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second patients record ordered by the type field
        patients = await patients.prisma().find_first(
            skip=1,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.patientsWhereInput] = None,
        cursor: Optional[types.patientsWhereUniqueInput] = None,
        include: Optional[types.patientsInclude] = None,
        order: Optional[Union[types.patientsOrderByInput, List[types.patientsOrderByInput]]] = None,
        distinct: Optional[List[types.patientsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single patients record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            patients filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned patients model
        order
            Order the returned patients records by any field
        distinct
            Filter patients records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.patients
            The first patients record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second patients record ordered by the species field
        patients = await patients.prisma().find_first_or_raise(
            skip=1,
            order={
                'species': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.patientsUpdateInput,
        where: types.patientsWhereUniqueInput,
        include: Optional[types.patientsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single patients record.

        Parameters
        ----------
        data
            patients record data specifying what to update
        where
            patients filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned patients model

        Returns
        -------
        prisma.models.patients
            The updated patients record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        patients = await patients.prisma().update(
            where={
                'patientid': 1513050921,
            },
            data={
                # data to update the patients record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.patientsWhereUniqueInput,
        data: types.patientsUpsertInput,
        include: Optional[types.patientsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            patients filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned patients model

        Returns
        -------
        prisma.models.patients
            The created or updated patients record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        patients = await patients.prisma().upsert(
            where={
                'patientid': 204674734,
            },
            data={
                'create': {
                    'patientid': 204674734,
                    'name': 'bchgafhjed',
                    'gender': enums.genders.M,
                    'type': 'heffgjdei',
                    'clientid': 307876141,
                },
                'update': {
                    'name': 'bchgafhjed',
                    'gender': enums.genders.M,
                    'type': 'heffgjdei',
                    'clientid': 307876141,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.patientsUpdateManyMutationInput,
        where: types.patientsWhereInput,
    ) -> int:
        """Update multiple patients records

        Parameters
        ----------
        data
            patients data to update the selected patients records to
        where
            Filter to select the patients records to update

        Returns
        -------
        int
            The total number of patients records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all patients records
        total = await patients.prisma().update_many(
            data={
                'birthdate': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.patientsWhereInput] = None,
        cursor: Optional[types.patientsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of patients records present in the database

        Parameters
        ----------
        select
            Select the patients fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            patients filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.patientsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await patients.prisma().count()

        # results: prisma.types.patientsCountAggregateOutput
        results = await patients.prisma().count(
            select={
                '_all': True,
                'numberid': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.patientsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.patientsWhereInput] = None,
        cursor: Optional[types.patientsWhereUniqueInput] = None,
    ) -> types.patientsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.patientsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.patientsWhereInput] = None,
        cursor: Optional[types.patientsWhereUniqueInput] = None,
    ) -> Union[int, types.patientsCountAggregateOutput]:
        """Count the number of patients records present in the database

        Parameters
        ----------
        select
            Select the patients fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            patients filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.patientsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await patients.prisma().count()

        # results: prisma.types.patientsCountAggregateOutput
        results = await patients.prisma().count(
            select={
                '_all': True,
                'color': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.patientsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.patientsWhereInput] = None
    ) -> int:
        """Delete multiple patients records.

        Parameters
        ----------
        where
            Optional patients filter to find the records to be deleted

        Returns
        -------
        int
            The total number of patients records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all patients records
        total = await patients.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.patientsScalarFieldKeys'],
        *,
        where: Optional['types.patientsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.patientsAvgAggregateInput'] = None,
        sum: Optional['types.patientsSumAggregateInput'] = None,
        min: Optional['types.patientsMinAggregateInput'] = None,
        max: Optional['types.patientsMaxAggregateInput'] = None,
        having: Optional['types.patientsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.patientsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.patientsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.patientsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.patientsGroupByOutput']:
        """Group patients records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar patients fields to group records by
        where
            patients filter to select records
        take
            Limit the maximum number of patients records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.patientsGroupByOutput]
            A list of dictionaries representing the patients record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group patients records by clientid values
        # and count how many records are in each group
        results = await patients.prisma().group_by(
            ['clientid'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class patients_allergiesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.patients_allergies]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await patients_allergies.prisma().query_raw(
            'SELECT * FROM patients_allergies WHERE patientid = $1',
            2067651663,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.patients_allergies
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await patients_allergies.prisma().query_first(
            'SELECT * FROM patients_allergies WHERE allergyid = $1',
            1183911900,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.patients_allergiesCreateInput,
        include: Optional[types.patients_allergiesInclude] = None
    ) -> _PrismaModelT:
        """Create a new patients_allergies record.

        Parameters
        ----------
        data
            patients_allergies record data
        include
            Specifies which relations should be loaded on the returned patients_allergies model

        Returns
        -------
        prisma.models.patients_allergies
            The created patients_allergies record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a patients_allergies record from just the required fields
        patients_allergies = await patients_allergies.prisma().create(
            data={
                # data to create a patients_allergies record
                'patientid': 1589704933,
                'allergyid': 1243475898,
                'status': enums.statuses.ACTIF,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.patients_allergiesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple patients_allergies records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of patients_allergies record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await patients_allergies.prisma().create_many(
            data=[
                {
                    # data to create a patients_allergies record
                    'patientid': 1369828971,
                    'allergyid': 1678593480,
                    'status': enums.statuses.ACTIF,
                },
                {
                    # data to create a patients_allergies record
                    'patientid': 403521121,
                    'allergyid': 648760710,
                    'status': enums.statuses.ACTIF,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.patients_allergiesWhereUniqueInput,
        include: Optional[types.patients_allergiesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single patients_allergies record.

        Parameters
        ----------
        where
            patients_allergies filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned patients_allergies model

        Returns
        -------
        prisma.models.patients_allergies
            The deleted patients_allergies record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        patients_allergies = await patients_allergies.prisma().delete(
            where={
                # patients_allergies where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.patients_allergiesWhereUniqueInput,
        include: Optional[types.patients_allergiesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique patients_allergies record.

        Parameters
        ----------
        where
            patients_allergies filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned patients_allergies model

        Returns
        -------
        prisma.models.patients_allergies
            The found patients_allergies record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        patients_allergies = await patients_allergies.prisma().find_unique(
            where={
                # patients_allergies where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.patients_allergiesWhereUniqueInput,
        include: Optional[types.patients_allergiesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique patients_allergies record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            patients_allergies filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned patients_allergies model

        Returns
        -------
        prisma.models.patients_allergies
            The found patients_allergies record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        patients_allergies = await patients_allergies.prisma().find_unique_or_raise(
            where={
                # patients_allergies where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.patients_allergiesWhereInput] = None,
        cursor: Optional[types.patients_allergiesWhereUniqueInput] = None,
        include: Optional[types.patients_allergiesInclude] = None,
        order: Optional[Union[types.patients_allergiesOrderByInput, List[types.patients_allergiesOrderByInput]]] = None,
        distinct: Optional[List[types.patients_allergiesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple patients_allergies records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of patients_allergies records returned
        skip
            Ignore the first N results
        where
            patients_allergies filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned patients_allergies model
        order
            Order the returned patients_allergies records by any field
        distinct
            Filter patients_allergies records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.patients_allergies]
            The list of all patients_allergies records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 patients_allergies records
        patients_allergies = await patients_allergies.prisma().find_many(take=10)

        # find the first 5 patients_allergies records ordered by the status field
        patients_allergies = await patients_allergies.prisma().find_many(
            take=5,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.patients_allergiesWhereInput] = None,
        cursor: Optional[types.patients_allergiesWhereUniqueInput] = None,
        include: Optional[types.patients_allergiesInclude] = None,
        order: Optional[Union[types.patients_allergiesOrderByInput, List[types.patients_allergiesOrderByInput]]] = None,
        distinct: Optional[List[types.patients_allergiesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single patients_allergies record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            patients_allergies filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned patients_allergies model
        order
            Order the returned patients_allergies records by any field
        distinct
            Filter patients_allergies records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.patients_allergies
            The first patients_allergies record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second patients_allergies record ordered by the patientid field
        patients_allergies = await patients_allergies.prisma().find_first(
            skip=1,
            order={
                'patientid': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.patients_allergiesWhereInput] = None,
        cursor: Optional[types.patients_allergiesWhereUniqueInput] = None,
        include: Optional[types.patients_allergiesInclude] = None,
        order: Optional[Union[types.patients_allergiesOrderByInput, List[types.patients_allergiesOrderByInput]]] = None,
        distinct: Optional[List[types.patients_allergiesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single patients_allergies record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            patients_allergies filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned patients_allergies model
        order
            Order the returned patients_allergies records by any field
        distinct
            Filter patients_allergies records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.patients_allergies
            The first patients_allergies record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second patients_allergies record ordered by the allergyid field
        patients_allergies = await patients_allergies.prisma().find_first_or_raise(
            skip=1,
            order={
                'allergyid': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.patients_allergiesUpdateInput,
        where: types.patients_allergiesWhereUniqueInput,
        include: Optional[types.patients_allergiesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single patients_allergies record.

        Parameters
        ----------
        data
            patients_allergies record data specifying what to update
        where
            patients_allergies filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned patients_allergies model

        Returns
        -------
        prisma.models.patients_allergies
            The updated patients_allergies record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        patients_allergies = await patients_allergies.prisma().update(
            where={
                # patients_allergies where unique filter

            },
            data={
                # data to update the patients_allergies record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.patients_allergiesWhereUniqueInput,
        data: types.patients_allergiesUpsertInput,
        include: Optional[types.patients_allergiesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            patients_allergies filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned patients_allergies model

        Returns
        -------
        prisma.models.patients_allergies
            The created or updated patients_allergies record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        patients_allergies = await patients_allergies.prisma().upsert(
            where={
                # patients_allergies where unique filter
            },
            data={
                'create': {
                    # patients_allergies data to be set if the record does not exist
                },
                'update': {
                    # patients_allergies data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.patients_allergiesUpdateManyMutationInput,
        where: types.patients_allergiesWhereInput,
    ) -> int:
        """Update multiple patients_allergies records

        Parameters
        ----------
        data
            patients_allergies data to update the selected patients_allergies records to
        where
            Filter to select the patients_allergies records to update

        Returns
        -------
        int
            The total number of patients_allergies records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all patients_allergies records
        total = await patients_allergies.prisma().update_many(
            data={
                'status': enums.statuses.ACTIF
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.patients_allergiesWhereInput] = None,
        cursor: Optional[types.patients_allergiesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of patients_allergies records present in the database

        Parameters
        ----------
        select
            Select the patients_allergies fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            patients_allergies filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.patients_allergiesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await patients_allergies.prisma().count()

        # results: prisma.types.patients_allergiesCountAggregateOutput
        results = await patients_allergies.prisma().count(
            select={
                '_all': True,
                'patientid': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.patients_allergiesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.patients_allergiesWhereInput] = None,
        cursor: Optional[types.patients_allergiesWhereUniqueInput] = None,
    ) -> types.patients_allergiesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.patients_allergiesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.patients_allergiesWhereInput] = None,
        cursor: Optional[types.patients_allergiesWhereUniqueInput] = None,
    ) -> Union[int, types.patients_allergiesCountAggregateOutput]:
        """Count the number of patients_allergies records present in the database

        Parameters
        ----------
        select
            Select the patients_allergies fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            patients_allergies filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.patients_allergiesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await patients_allergies.prisma().count()

        # results: prisma.types.patients_allergiesCountAggregateOutput
        results = await patients_allergies.prisma().count(
            select={
                '_all': True,
                'allergyid': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.patients_allergiesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.patients_allergiesWhereInput] = None
    ) -> int:
        """Delete multiple patients_allergies records.

        Parameters
        ----------
        where
            Optional patients_allergies filter to find the records to be deleted

        Returns
        -------
        int
            The total number of patients_allergies records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all patients_allergies records
        total = await patients_allergies.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.patients_allergiesScalarFieldKeys'],
        *,
        where: Optional['types.patients_allergiesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.patients_allergiesAvgAggregateInput'] = None,
        sum: Optional['types.patients_allergiesSumAggregateInput'] = None,
        min: Optional['types.patients_allergiesMinAggregateInput'] = None,
        max: Optional['types.patients_allergiesMaxAggregateInput'] = None,
        having: Optional['types.patients_allergiesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.patients_allergiesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.patients_allergiesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.patients_allergiesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.patients_allergiesGroupByOutput']:
        """Group patients_allergies records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar patients_allergies fields to group records by
        where
            patients_allergies filter to select records
        take
            Limit the maximum number of patients_allergies records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.patients_allergiesGroupByOutput]
            A list of dictionaries representing the patients_allergies record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group patients_allergies records by status values
        # and count how many records are in each group
        results = await patients_allergies.prisma().group_by(
            ['status'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class prescriptionsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.prescriptions]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await prescriptions.prisma().query_raw(
            'SELECT * FROM prescriptions WHERE prescriptionid = $1',
            607323719,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.prescriptions
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await prescriptions.prisma().query_first(
            'SELECT * FROM prescriptions WHERE motive = $1',
            'begiijahea',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.prescriptionsCreateInput,
        include: Optional[types.prescriptionsInclude] = None
    ) -> _PrismaModelT:
        """Create a new prescriptions record.

        Parameters
        ----------
        data
            prescriptions record data
        include
            Specifies which relations should be loaded on the returned prescriptions model

        Returns
        -------
        prisma.models.prescriptions
            The created prescriptions record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a prescriptions record from just the required fields
        prescriptions = await prescriptions.prisma().create(
            data={
                # data to create a prescriptions record
                'prescriptionlink': 'gcjadjaaf',
                'patientid': 1214168082,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.prescriptionsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple prescriptions records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of prescriptions record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await prescriptions.prisma().create_many(
            data=[
                {
                    # data to create a prescriptions record
                    'prescriptionlink': 'ijigbdcbj',
                    'patientid': 658378208,
                },
                {
                    # data to create a prescriptions record
                    'prescriptionlink': 'jfegcaafh',
                    'patientid': 1214809950,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.prescriptionsWhereUniqueInput,
        include: Optional[types.prescriptionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single prescriptions record.

        Parameters
        ----------
        where
            prescriptions filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned prescriptions model

        Returns
        -------
        prisma.models.prescriptions
            The deleted prescriptions record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        prescriptions = await prescriptions.prisma().delete(
            where={
                'prescriptionid': 1047820095,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.prescriptionsWhereUniqueInput,
        include: Optional[types.prescriptionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique prescriptions record.

        Parameters
        ----------
        where
            prescriptions filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned prescriptions model

        Returns
        -------
        prisma.models.prescriptions
            The found prescriptions record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        prescriptions = await prescriptions.prisma().find_unique(
            where={
                'prescriptionid': 1302734860,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.prescriptionsWhereUniqueInput,
        include: Optional[types.prescriptionsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique prescriptions record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            prescriptions filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned prescriptions model

        Returns
        -------
        prisma.models.prescriptions
            The found prescriptions record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        prescriptions = await prescriptions.prisma().find_unique_or_raise(
            where={
                'prescriptionid': 893052245,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.prescriptionsWhereInput] = None,
        cursor: Optional[types.prescriptionsWhereUniqueInput] = None,
        include: Optional[types.prescriptionsInclude] = None,
        order: Optional[Union[types.prescriptionsOrderByInput, List[types.prescriptionsOrderByInput]]] = None,
        distinct: Optional[List[types.prescriptionsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple prescriptions records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of prescriptions records returned
        skip
            Ignore the first N results
        where
            prescriptions filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned prescriptions model
        order
            Order the returned prescriptions records by any field
        distinct
            Filter prescriptions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.prescriptions]
            The list of all prescriptions records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 prescriptions records
        prescriptions = await prescriptions.prisma().find_many(take=10)

        # find the first 5 prescriptions records ordered by the prescriptionlink field
        prescriptions = await prescriptions.prisma().find_many(
            take=5,
            order={
                'prescriptionlink': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.prescriptionsWhereInput] = None,
        cursor: Optional[types.prescriptionsWhereUniqueInput] = None,
        include: Optional[types.prescriptionsInclude] = None,
        order: Optional[Union[types.prescriptionsOrderByInput, List[types.prescriptionsOrderByInput]]] = None,
        distinct: Optional[List[types.prescriptionsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single prescriptions record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            prescriptions filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned prescriptions model
        order
            Order the returned prescriptions records by any field
        distinct
            Filter prescriptions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.prescriptions
            The first prescriptions record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second prescriptions record ordered by the created_at field
        prescriptions = await prescriptions.prisma().find_first(
            skip=1,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.prescriptionsWhereInput] = None,
        cursor: Optional[types.prescriptionsWhereUniqueInput] = None,
        include: Optional[types.prescriptionsInclude] = None,
        order: Optional[Union[types.prescriptionsOrderByInput, List[types.prescriptionsOrderByInput]]] = None,
        distinct: Optional[List[types.prescriptionsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single prescriptions record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            prescriptions filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned prescriptions model
        order
            Order the returned prescriptions records by any field
        distinct
            Filter prescriptions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.prescriptions
            The first prescriptions record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second prescriptions record ordered by the patientid field
        prescriptions = await prescriptions.prisma().find_first_or_raise(
            skip=1,
            order={
                'patientid': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.prescriptionsUpdateInput,
        where: types.prescriptionsWhereUniqueInput,
        include: Optional[types.prescriptionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single prescriptions record.

        Parameters
        ----------
        data
            prescriptions record data specifying what to update
        where
            prescriptions filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned prescriptions model

        Returns
        -------
        prisma.models.prescriptions
            The updated prescriptions record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        prescriptions = await prescriptions.prisma().update(
            where={
                'prescriptionid': 280083306,
            },
            data={
                # data to update the prescriptions record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.prescriptionsWhereUniqueInput,
        data: types.prescriptionsUpsertInput,
        include: Optional[types.prescriptionsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            prescriptions filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned prescriptions model

        Returns
        -------
        prisma.models.prescriptions
            The created or updated prescriptions record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        prescriptions = await prescriptions.prisma().upsert(
            where={
                'prescriptionid': 549668955,
            },
            data={
                'create': {
                    'prescriptionid': 549668955,
                    'prescriptionlink': 'jfegcaafh',
                    'patientid': 1214809950,
                },
                'update': {
                    'prescriptionlink': 'jfegcaafh',
                    'patientid': 1214809950,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.prescriptionsUpdateManyMutationInput,
        where: types.prescriptionsWhereInput,
    ) -> int:
        """Update multiple prescriptions records

        Parameters
        ----------
        data
            prescriptions data to update the selected prescriptions records to
        where
            Filter to select the prescriptions records to update

        Returns
        -------
        int
            The total number of prescriptions records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all prescriptions records
        total = await prescriptions.prisma().update_many(
            data={
                'prescriptionid': 76790008
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.prescriptionsWhereInput] = None,
        cursor: Optional[types.prescriptionsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of prescriptions records present in the database

        Parameters
        ----------
        select
            Select the prescriptions fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            prescriptions filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.prescriptionsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await prescriptions.prisma().count()

        # results: prisma.types.prescriptionsCountAggregateOutput
        results = await prescriptions.prisma().count(
            select={
                '_all': True,
                'motive': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.prescriptionsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.prescriptionsWhereInput] = None,
        cursor: Optional[types.prescriptionsWhereUniqueInput] = None,
    ) -> types.prescriptionsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.prescriptionsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.prescriptionsWhereInput] = None,
        cursor: Optional[types.prescriptionsWhereUniqueInput] = None,
    ) -> Union[int, types.prescriptionsCountAggregateOutput]:
        """Count the number of prescriptions records present in the database

        Parameters
        ----------
        select
            Select the prescriptions fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            prescriptions filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.prescriptionsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await prescriptions.prisma().count()

        # results: prisma.types.prescriptionsCountAggregateOutput
        results = await prescriptions.prisma().count(
            select={
                '_all': True,
                'prescriptionlink': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.prescriptionsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.prescriptionsWhereInput] = None
    ) -> int:
        """Delete multiple prescriptions records.

        Parameters
        ----------
        where
            Optional prescriptions filter to find the records to be deleted

        Returns
        -------
        int
            The total number of prescriptions records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all prescriptions records
        total = await prescriptions.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.prescriptionsScalarFieldKeys'],
        *,
        where: Optional['types.prescriptionsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.prescriptionsAvgAggregateInput'] = None,
        sum: Optional['types.prescriptionsSumAggregateInput'] = None,
        min: Optional['types.prescriptionsMinAggregateInput'] = None,
        max: Optional['types.prescriptionsMaxAggregateInput'] = None,
        having: Optional['types.prescriptionsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.prescriptionsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.prescriptionsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.prescriptionsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.prescriptionsGroupByOutput']:
        """Group prescriptions records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar prescriptions fields to group records by
        where
            prescriptions filter to select records
        take
            Limit the maximum number of prescriptions records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.prescriptionsGroupByOutput]
            A list of dictionaries representing the prescriptions record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group prescriptions records by created_at values
        # and count how many records are in each group
        results = await prescriptions.prisma().group_by(
            ['created_at'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class product_typesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.product_types]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await product_types.prisma().query_raw(
            'SELECT * FROM product_types WHERE producttypeid = $1',
            2098299345,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.product_types
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await product_types.prisma().query_first(
            'SELECT * FROM product_types WHERE name = $1',
            'cefjaadec',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.product_typesCreateInput,
        include: Optional[types.product_typesInclude] = None
    ) -> _PrismaModelT:
        """Create a new product_types record.

        Parameters
        ----------
        data
            product_types record data
        include
            Specifies which relations should be loaded on the returned product_types model

        Returns
        -------
        prisma.models.product_types
            The created product_types record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a product_types record from just the required fields
        product_types = await product_types.prisma().create(
            data={
                # data to create a product_types record
                'name': 'ibbigdigd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.product_typesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple product_types records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of product_types record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await product_types.prisma().create_many(
            data=[
                {
                    # data to create a product_types record
                    'name': 'bdiiiabbii',
                },
                {
                    # data to create a product_types record
                    'name': 'hfcfhhadh',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.product_typesWhereUniqueInput,
        include: Optional[types.product_typesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single product_types record.

        Parameters
        ----------
        where
            product_types filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned product_types model

        Returns
        -------
        prisma.models.product_types
            The deleted product_types record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product_types = await product_types.prisma().delete(
            where={
                'producttypeid': 1187663298,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.product_typesWhereUniqueInput,
        include: Optional[types.product_typesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique product_types record.

        Parameters
        ----------
        where
            product_types filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned product_types model

        Returns
        -------
        prisma.models.product_types
            The found product_types record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product_types = await product_types.prisma().find_unique(
            where={
                'producttypeid': 769681363,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.product_typesWhereUniqueInput,
        include: Optional[types.product_typesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique product_types record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            product_types filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned product_types model

        Returns
        -------
        prisma.models.product_types
            The found product_types record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product_types = await product_types.prisma().find_unique_or_raise(
            where={
                'producttypeid': 1214295824,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.product_typesWhereInput] = None,
        cursor: Optional[types.product_typesWhereUniqueInput] = None,
        include: Optional[types.product_typesInclude] = None,
        order: Optional[Union[types.product_typesOrderByInput, List[types.product_typesOrderByInput]]] = None,
        distinct: Optional[List[types.product_typesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple product_types records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of product_types records returned
        skip
            Ignore the first N results
        where
            product_types filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned product_types model
        order
            Order the returned product_types records by any field
        distinct
            Filter product_types records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.product_types]
            The list of all product_types records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 product_types records
        product_types = await product_types.prisma().find_many(take=10)

        # find the first 5 product_types records ordered by the producttypeid field
        product_types = await product_types.prisma().find_many(
            take=5,
            order={
                'producttypeid': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.product_typesWhereInput] = None,
        cursor: Optional[types.product_typesWhereUniqueInput] = None,
        include: Optional[types.product_typesInclude] = None,
        order: Optional[Union[types.product_typesOrderByInput, List[types.product_typesOrderByInput]]] = None,
        distinct: Optional[List[types.product_typesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single product_types record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            product_types filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned product_types model
        order
            Order the returned product_types records by any field
        distinct
            Filter product_types records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.product_types
            The first product_types record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second product_types record ordered by the name field
        product_types = await product_types.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.product_typesWhereInput] = None,
        cursor: Optional[types.product_typesWhereUniqueInput] = None,
        include: Optional[types.product_typesInclude] = None,
        order: Optional[Union[types.product_typesOrderByInput, List[types.product_typesOrderByInput]]] = None,
        distinct: Optional[List[types.product_typesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single product_types record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            product_types filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned product_types model
        order
            Order the returned product_types records by any field
        distinct
            Filter product_types records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.product_types
            The first product_types record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second product_types record ordered by the producttypeid field
        product_types = await product_types.prisma().find_first_or_raise(
            skip=1,
            order={
                'producttypeid': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.product_typesUpdateInput,
        where: types.product_typesWhereUniqueInput,
        include: Optional[types.product_typesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single product_types record.

        Parameters
        ----------
        data
            product_types record data specifying what to update
        where
            product_types filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned product_types model

        Returns
        -------
        prisma.models.product_types
            The updated product_types record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        product_types = await product_types.prisma().update(
            where={
                'producttypeid': 1021417993,
            },
            data={
                # data to update the product_types record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.product_typesWhereUniqueInput,
        data: types.product_typesUpsertInput,
        include: Optional[types.product_typesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            product_types filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned product_types model

        Returns
        -------
        prisma.models.product_types
            The created or updated product_types record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product_types = await product_types.prisma().upsert(
            where={
                'producttypeid': 351503374,
            },
            data={
                'create': {
                    'producttypeid': 351503374,
                    'name': 'hfcfhhadh',
                },
                'update': {
                    'name': 'hfcfhhadh',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.product_typesUpdateManyMutationInput,
        where: types.product_typesWhereInput,
    ) -> int:
        """Update multiple product_types records

        Parameters
        ----------
        data
            product_types data to update the selected product_types records to
        where
            Filter to select the product_types records to update

        Returns
        -------
        int
            The total number of product_types records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all product_types records
        total = await product_types.prisma().update_many(
            data={
                'name': 'bdcbbieibf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.product_typesWhereInput] = None,
        cursor: Optional[types.product_typesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of product_types records present in the database

        Parameters
        ----------
        select
            Select the product_types fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            product_types filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.product_typesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await product_types.prisma().count()

        # results: prisma.types.product_typesCountAggregateOutput
        results = await product_types.prisma().count(
            select={
                '_all': True,
                'producttypeid': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.product_typesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.product_typesWhereInput] = None,
        cursor: Optional[types.product_typesWhereUniqueInput] = None,
    ) -> types.product_typesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.product_typesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.product_typesWhereInput] = None,
        cursor: Optional[types.product_typesWhereUniqueInput] = None,
    ) -> Union[int, types.product_typesCountAggregateOutput]:
        """Count the number of product_types records present in the database

        Parameters
        ----------
        select
            Select the product_types fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            product_types filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.product_typesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await product_types.prisma().count()

        # results: prisma.types.product_typesCountAggregateOutput
        results = await product_types.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.product_typesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.product_typesWhereInput] = None
    ) -> int:
        """Delete multiple product_types records.

        Parameters
        ----------
        where
            Optional product_types filter to find the records to be deleted

        Returns
        -------
        int
            The total number of product_types records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all product_types records
        total = await product_types.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.product_typesScalarFieldKeys'],
        *,
        where: Optional['types.product_typesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.product_typesAvgAggregateInput'] = None,
        sum: Optional['types.product_typesSumAggregateInput'] = None,
        min: Optional['types.product_typesMinAggregateInput'] = None,
        max: Optional['types.product_typesMaxAggregateInput'] = None,
        having: Optional['types.product_typesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.product_typesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.product_typesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.product_typesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.product_typesGroupByOutput']:
        """Group product_types records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar product_types fields to group records by
        where
            product_types filter to select records
        take
            Limit the maximum number of product_types records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.product_typesGroupByOutput]
            A list of dictionaries representing the product_types record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group product_types records by producttypeid values
        # and count how many records are in each group
        results = await product_types.prisma().group_by(
            ['producttypeid'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class productsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.products]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await products.prisma().query_raw(
            'SELECT * FROM products WHERE productid = $1',
            369732668,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.products
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await products.prisma().query_first(
            'SELECT * FROM products WHERE name = $1',
            'bbjbcdfabd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.productsCreateInput,
        include: Optional[types.productsInclude] = None
    ) -> _PrismaModelT:
        """Create a new products record.

        Parameters
        ----------
        data
            products record data
        include
            Specifies which relations should be loaded on the returned products model

        Returns
        -------
        prisma.models.products
            The created products record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a products record from just the required fields
        products = await products.prisma().create(
            data={
                # data to create a products record
                'name': 'gchfgbcec',
                'sellingprice': Decimal('1872952907.179328'),
                'cost': Decimal('1814397249.192309'),
                'tva': Decimal('1277244455.116085'),
                'quantity': 361230461,
                'producttypeid': 1406511986,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.productsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple products records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of products record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await products.prisma().create_many(
            data=[
                {
                    # data to create a products record
                    'name': 'beicihhijb',
                    'sellingprice': Decimal('566623296.22911'),
                    'cost': Decimal('1750011070.41094'),
                    'tva': Decimal('909024364.75561'),
                    'quantity': 1802188490,
                    'producttypeid': 294916155,
                },
                {
                    # data to create a products record
                    'name': 'fgeahddae',
                    'sellingprice': Decimal('380648625.103061'),
                    'cost': Decimal('816411927.108409'),
                    'tva': Decimal('1079702253.75575'),
                    'quantity': 1128680371,
                    'producttypeid': 259061104,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.productsWhereUniqueInput,
        include: Optional[types.productsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single products record.

        Parameters
        ----------
        where
            products filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned products model

        Returns
        -------
        prisma.models.products
            The deleted products record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        products = await products.prisma().delete(
            where={
                'productid': 1115738345,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.productsWhereUniqueInput,
        include: Optional[types.productsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique products record.

        Parameters
        ----------
        where
            products filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned products model

        Returns
        -------
        prisma.models.products
            The found products record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        products = await products.prisma().find_unique(
            where={
                'productid': 1303781742,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.productsWhereUniqueInput,
        include: Optional[types.productsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique products record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            products filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned products model

        Returns
        -------
        prisma.models.products
            The found products record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        products = await products.prisma().find_unique_or_raise(
            where={
                'productid': 1573908495,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.productsWhereInput] = None,
        cursor: Optional[types.productsWhereUniqueInput] = None,
        include: Optional[types.productsInclude] = None,
        order: Optional[Union[types.productsOrderByInput, List[types.productsOrderByInput]]] = None,
        distinct: Optional[List[types.productsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple products records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of products records returned
        skip
            Ignore the first N results
        where
            products filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned products model
        order
            Order the returned products records by any field
        distinct
            Filter products records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.products]
            The list of all products records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 products records
        products = await products.prisma().find_many(take=10)

        # find the first 5 products records ordered by the description field
        products = await products.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.productsWhereInput] = None,
        cursor: Optional[types.productsWhereUniqueInput] = None,
        include: Optional[types.productsInclude] = None,
        order: Optional[Union[types.productsOrderByInput, List[types.productsOrderByInput]]] = None,
        distinct: Optional[List[types.productsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single products record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            products filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned products model
        order
            Order the returned products records by any field
        distinct
            Filter products records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.products
            The first products record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second products record ordered by the sellingprice field
        products = await products.prisma().find_first(
            skip=1,
            order={
                'sellingprice': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.productsWhereInput] = None,
        cursor: Optional[types.productsWhereUniqueInput] = None,
        include: Optional[types.productsInclude] = None,
        order: Optional[Union[types.productsOrderByInput, List[types.productsOrderByInput]]] = None,
        distinct: Optional[List[types.productsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single products record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            products filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned products model
        order
            Order the returned products records by any field
        distinct
            Filter products records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.products
            The first products record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second products record ordered by the cost field
        products = await products.prisma().find_first_or_raise(
            skip=1,
            order={
                'cost': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.productsUpdateInput,
        where: types.productsWhereUniqueInput,
        include: Optional[types.productsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single products record.

        Parameters
        ----------
        data
            products record data specifying what to update
        where
            products filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned products model

        Returns
        -------
        prisma.models.products
            The updated products record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        products = await products.prisma().update(
            where={
                'productid': 1195899036,
            },
            data={
                # data to update the products record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.productsWhereUniqueInput,
        data: types.productsUpsertInput,
        include: Optional[types.productsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            products filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned products model

        Returns
        -------
        prisma.models.products
            The created or updated products record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        products = await products.prisma().upsert(
            where={
                'productid': 739021477,
            },
            data={
                'create': {
                    'productid': 739021477,
                    'name': 'fgeahddae',
                    'sellingprice': Decimal('380648625.103061'),
                    'cost': Decimal('816411927.108409'),
                    'tva': Decimal('1079702253.75575'),
                    'quantity': 1128680371,
                    'producttypeid': 259061104,
                },
                'update': {
                    'name': 'fgeahddae',
                    'sellingprice': Decimal('380648625.103061'),
                    'cost': Decimal('816411927.108409'),
                    'tva': Decimal('1079702253.75575'),
                    'quantity': 1128680371,
                    'producttypeid': 259061104,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.productsUpdateManyMutationInput,
        where: types.productsWhereInput,
    ) -> int:
        """Update multiple products records

        Parameters
        ----------
        data
            products data to update the selected products records to
        where
            Filter to select the products records to update

        Returns
        -------
        int
            The total number of products records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all products records
        total = await products.prisma().update_many(
            data={
                'tva': Decimal('1722214010.126913')
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.productsWhereInput] = None,
        cursor: Optional[types.productsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of products records present in the database

        Parameters
        ----------
        select
            Select the products fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            products filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.productsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await products.prisma().count()

        # results: prisma.types.productsCountAggregateOutput
        results = await products.prisma().count(
            select={
                '_all': True,
                'quantity': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.productsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.productsWhereInput] = None,
        cursor: Optional[types.productsWhereUniqueInput] = None,
    ) -> types.productsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.productsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.productsWhereInput] = None,
        cursor: Optional[types.productsWhereUniqueInput] = None,
    ) -> Union[int, types.productsCountAggregateOutput]:
        """Count the number of products records present in the database

        Parameters
        ----------
        select
            Select the products fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            products filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.productsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await products.prisma().count()

        # results: prisma.types.productsCountAggregateOutput
        results = await products.prisma().count(
            select={
                '_all': True,
                'producttypeid': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.productsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.productsWhereInput] = None
    ) -> int:
        """Delete multiple products records.

        Parameters
        ----------
        where
            Optional products filter to find the records to be deleted

        Returns
        -------
        int
            The total number of products records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all products records
        total = await products.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.productsScalarFieldKeys'],
        *,
        where: Optional['types.productsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.productsAvgAggregateInput'] = None,
        sum: Optional['types.productsSumAggregateInput'] = None,
        min: Optional['types.productsMinAggregateInput'] = None,
        max: Optional['types.productsMaxAggregateInput'] = None,
        having: Optional['types.productsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.productsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.productsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.productsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.productsGroupByOutput']:
        """Group products records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar products fields to group records by
        where
            products filter to select records
        take
            Limit the maximum number of products records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.productsGroupByOutput]
            A list of dictionaries representing the products record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group products records by productid values
        # and count how many records are in each group
        results = await products.prisma().group_by(
            ['productid'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class usersActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.users]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await users.prisma().query_raw(
            'SELECT * FROM users WHERE userid = $1',
            573178504,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.users
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await users.prisma().query_first(
            'SELECT * FROM users WHERE username = $1',
            'beeacgfcej',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.usersCreateInput,
        include: Optional[types.usersInclude] = None
    ) -> _PrismaModelT:
        """Create a new users record.

        Parameters
        ----------
        data
            users record data
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The created users record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a users record from just the required fields
        users = await users.prisma().create(
            data={
                # data to create a users record
                'username': 'bbifhdiicc',
                'password': 'bgjeccejad',
                'role': enums.roles.DIRECTEUR,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.usersCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple users records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of users record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await users.prisma().create_many(
            data=[
                {
                    # data to create a users record
                    'username': 'bjagdgabbg',
                    'password': 'bjbbcffdij',
                    'role': enums.roles.DIRECTEUR,
                },
                {
                    # data to create a users record
                    'username': 'begcgchdi',
                    'password': 'bhbjceagbb',
                    'role': enums.roles.DIRECTEUR,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.usersWhereUniqueInput,
        include: Optional[types.usersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single users record.

        Parameters
        ----------
        where
            users filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The deleted users record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await users.prisma().delete(
            where={
                'userid': 1948555936,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.usersWhereUniqueInput,
        include: Optional[types.usersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique users record.

        Parameters
        ----------
        where
            users filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The found users record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await users.prisma().find_unique(
            where={
                'userid': 1383253593,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.usersWhereUniqueInput,
        include: Optional[types.usersInclude] = None
    ) -> _PrismaModelT:
        """Find a unique users record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            users filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The found users record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await users.prisma().find_unique_or_raise(
            where={
                'userid': 354664990,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
        include: Optional[types.usersInclude] = None,
        order: Optional[Union[types.usersOrderByInput, List[types.usersOrderByInput]]] = None,
        distinct: Optional[List[types.usersScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple users records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of users records returned
        skip
            Ignore the first N results
        where
            users filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users model
        order
            Order the returned users records by any field
        distinct
            Filter users records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.users]
            The list of all users records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 users records
        users = await users.prisma().find_many(take=10)

        # find the first 5 users records ordered by the password field
        users = await users.prisma().find_many(
            take=5,
            order={
                'password': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
        include: Optional[types.usersInclude] = None,
        order: Optional[Union[types.usersOrderByInput, List[types.usersOrderByInput]]] = None,
        distinct: Optional[List[types.usersScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single users record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users model
        order
            Order the returned users records by any field
        distinct
            Filter users records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users
            The first users record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users record ordered by the role field
        users = await users.prisma().find_first(
            skip=1,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
        include: Optional[types.usersInclude] = None,
        order: Optional[Union[types.usersOrderByInput, List[types.usersOrderByInput]]] = None,
        distinct: Optional[List[types.usersScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single users record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users model
        order
            Order the returned users records by any field
        distinct
            Filter users records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users
            The first users record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users record ordered by the userid field
        users = await users.prisma().find_first_or_raise(
            skip=1,
            order={
                'userid': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.usersUpdateInput,
        where: types.usersWhereUniqueInput,
        include: Optional[types.usersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single users record.

        Parameters
        ----------
        data
            users record data specifying what to update
        where
            users filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The updated users record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await users.prisma().update(
            where={
                'userid': 647166719,
            },
            data={
                # data to update the users record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.usersWhereUniqueInput,
        data: types.usersUpsertInput,
        include: Optional[types.usersInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            users filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The created or updated users record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await users.prisma().upsert(
            where={
                'userid': 357089484,
            },
            data={
                'create': {
                    'userid': 357089484,
                    'username': 'begcgchdi',
                    'password': 'bhbjceagbb',
                    'role': enums.roles.DIRECTEUR,
                },
                'update': {
                    'username': 'begcgchdi',
                    'password': 'bhbjceagbb',
                    'role': enums.roles.DIRECTEUR,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.usersUpdateManyMutationInput,
        where: types.usersWhereInput,
    ) -> int:
        """Update multiple users records

        Parameters
        ----------
        data
            users data to update the selected users records to
        where
            Filter to select the users records to update

        Returns
        -------
        int
            The total number of users records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all users records
        total = await users.prisma().update_many(
            data={
                'username': 'gbcdjgicb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
    ) -> int:
        """Count the number of users records present in the database

        Parameters
        ----------
        select
            Select the users fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.usersCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users.prisma().count()

        # results: prisma.types.usersCountAggregateOutput
        results = await users.prisma().count(
            select={
                '_all': True,
                'password': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.usersCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
    ) -> types.usersCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.usersCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
    ) -> Union[int, types.usersCountAggregateOutput]:
        """Count the number of users records present in the database

        Parameters
        ----------
        select
            Select the users fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.usersCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users.prisma().count()

        # results: prisma.types.usersCountAggregateOutput
        results = await users.prisma().count(
            select={
                '_all': True,
                'role': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.usersCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.usersWhereInput] = None
    ) -> int:
        """Delete multiple users records.

        Parameters
        ----------
        where
            Optional users filter to find the records to be deleted

        Returns
        -------
        int
            The total number of users records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all users records
        total = await users.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.usersScalarFieldKeys'],
        *,
        where: Optional['types.usersWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.usersAvgAggregateInput'] = None,
        sum: Optional['types.usersSumAggregateInput'] = None,
        min: Optional['types.usersMinAggregateInput'] = None,
        max: Optional['types.usersMaxAggregateInput'] = None,
        having: Optional['types.usersScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.usersCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.usersScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.usersScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.usersGroupByOutput']:
        """Group users records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar users fields to group records by
        where
            users filter to select records
        take
            Limit the maximum number of users records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.usersGroupByOutput]
            A list of dictionaries representing the users record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group users records by userid values
        # and count how many records are in each group
        results = await users.prisma().group_by(
            ['userid'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models